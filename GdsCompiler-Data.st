GdsObject subclass: #GdsDataStructure	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Data'!!GdsDataStructure commentStamp: 'kf 5/21/2009 13:24' prior: 0!A GdsDataStructure is abstract class for GPLII core data.Instance Variables!!GdsDataStructure methodsFor: 'arithmetic' stamp: 'kf 4/25/2009 00:07'!% aObject	^self applySymbol: #% to: aObject! !!GdsDataStructure methodsFor: 'arithmetic' stamp: 'kf 4/24/2009 22:17'!* aObject	^self applySymbol: #* to: aObject! !!GdsDataStructure methodsFor: 'arithmetic' stamp: 'kf 4/24/2009 22:17'!+ aObject	| v |	"self halt."	v := self applySymbol: #+ to: aObject.	^v.! !!GdsDataStructure methodsFor: 'arithmetic' stamp: 'kf 4/24/2009 22:17'!- aObject	^self applySymbol: #- to: aObject! !!GdsDataStructure methodsFor: 'arithmetic' stamp: 'kf 5/20/2009 00:48'!= aObject	(aObject isKindOf: GdsDataStructure ) ifFalse: [^false].	(self size = aObject size) ifFalse: [^false].	(self mode = aObject mode) ifFalse: [^false].	^self asSmalltalkValue = aObject asSmalltalkValue.! !!GdsDataStructure methodsFor: 'arithmetic' stamp: 'kf 5/26/2009 14:47'!applySymbol: aSymbol to: aObject 	^self illigalDataMode.! !!GdsDataStructure methodsFor: 'private' stamp: 'kf 6/12/2009 09:10'!applySymbolCheck: aSymbol to: aObject 	(#(+ - * %) includes: aSymbol) ifFalse: [self error: 'ILLIGAL ARITHMETIC OPERATOR'].	self isCharVector ifTrue: [^self illigalDataMode].	(self isKindOf: GdsNull) ifTrue: [^self illigalDataMode].	aObject isCharVector ifTrue: [^self illigalDataMode].	(aObject isKindOf: GdsNull) ifTrue: [^self illigalDataMode].	! !!GdsDataStructure methodsFor: 'private' stamp: 'kf 5/22/2009 23:19'!notSupportMatrixSubscription	^self error: 'Sorry: current implement not support Matrix subscription'.! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 5/23/2009 23:30'!asGdsFloating	^self subclassResponsibility! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 5/26/2009 12:00'!asGdsValue	^self! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 4/24/2009 16:48'!asGplValue	^self! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 6/12/2009 09:07'!asScalar	self isScalar ifTrue: [^self].	self size = 1		ifFalse: [^self error: 'CANT CONVERT TO SCALAR'].	^self at: 1.! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 4/25/2009 14:56'!asSmalltalkValue	^self subclassResponsibility.! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 5/26/2009 15:32'!asVector	^ self vectorClass withAll: self elements! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 5/26/2009 15:33'!asVector: aSize 	^ self vectorClass withAll: self elements ! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 5/20/2009 22:11'!gplSourceString	^self gplString.! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 4/25/2009 15:20'!gplString	^self asSmalltalkValue asString.! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 5/20/2009 22:56'!gplValueOfLength	^GdsInteger fromLiteral: self length.! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 4/27/2009 21:36'!gplValueOfRank	^GdsInteger fromLiteral: self rank.! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 4/27/2009 21:35'!gplValueOfShape	^GdsInteger fromLiteral: self shape.! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 4/27/2009 21:33'!gplValueOfSize	^GdsInteger fromLiteral: self size.	! !!GdsDataStructure methodsFor: 'convert' stamp: 'kf 5/22/2009 13:13'!gplValueOfTypeof	^GdsString fromLiteral: ('"', self typeString , '"')! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/22/2009 23:27'!at: aIndex	^self error: 'ILIIGAL ACCESS FOR SCALAR []'.! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/23/2009 23:01'!atSubscript: aGdsDataStructure.	^self subclassResponsibility.! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/23/2009 19:37'!atSubscript: aGdsDataStructure put: aGdsValue	^self subclassResponsibility! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/26/2009 10:12'!atSubscriptWithCheck: aGdsDataStructure 	| subscript |	subscript := self subscriptCheckForReturn: aGdsDataStructure.	^self atSubscript: subscript! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/26/2009 10:10'!atSubscriptWithCheck: aGdsDataStructure put: aGdsValue	| subscript |	subscript := self subscriptCheckForAssign: aGdsDataStructure.	^self atSubscript: subscript put: aGdsValue.! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/26/2009 11:22'!elements	^self subclassResponsibility.! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/19/2009 14:46'!length	^1.! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 11/10/2008 16:34'!mode	^self class mode.! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/27/2009 16:32'!nonIntegralValue	^self runtimeError: 'ILLIGAL SUBSCRIPT ACCESS. NON INTEGRAL VALUE'.! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 11/10/2008 16:04'!rank	^self class rank.	! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:10'!shape	^self class shape.! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 4/27/2009 21:34'!size	self subclassresponsibility! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 6/12/2009 09:09'!subscriptCheckFor: aSubscript 	(self isMemberOf: GdsMatrix)		ifFalse: [			(aSubscript = GdsNull instance)				ifTrue: [^self nonIntegralValue]].	aSubscript isCharVector		ifTrue: [^self nonIntegralValue].	(aSubscript isMemberOf: GdsMatrix)		ifTrue: [^self nonIntegralValue].	((aSubscript isMemberOf: GdsVector) or: [aSubscript isKindOf: GdsScalar]) 		ifTrue: [			(aSubscript sameAsInteger)				ifFalse: [^self nonIntegralValue]].	^ aSubscript! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/25/2009 22:58'!subscriptCheckForAssign: aSubscript 	^ self subscriptCheckFor: aSubscript! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/25/2009 22:57'!subscriptCheckForReturn: aSubscript 	^ self subscriptCheckFor: aSubscript! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 4/24/2009 13:43'!typeString	^self subclassResponsibility.! !!GdsDataStructure methodsFor: 'accessing' stamp: 'kf 5/23/2009 22:50'!vectorClass	^self typeString = 'CHAR' ifTrue: [GdsString] ifFalse: [GdsVector].! !!GdsDataStructure methodsFor: 'copying' stamp: 'kf 5/23/2009 23:26'!copy	^super copy copyValues.! !!GdsDataStructure methodsFor: 'copying' stamp: 'kf 5/23/2009 23:50'!copyValues! !!GdsDataStructure methodsFor: 'utility for subclass' stamp: 'kf 5/27/2009 16:33'!illigalDataMode	^self runtimeError: 'ILLIGAL DATA MODE'.! !!GdsDataStructure methodsFor: 'utility for subclass' stamp: 'kf 5/22/2009 23:27'!indexedValues: aIndexArray	^(aIndexArray collect: [:each | self at: each]) asArray! !!GdsDataStructure methodsFor: 'utility for subclass' stamp: 'kf 5/22/2009 23:40'!indexesOfSubscript: aGdsDataStructure	^aGdsDataStructure asVector elements collect: [:each | each asSmalltalkValue].! !!GdsDataStructure methodsFor: 'testing' stamp: 'kf 6/12/2009 08:48'!isCharVector	^false! !!GdsDataStructure methodsFor: 'testing' stamp: 'kf 6/11/2009 17:48'!isList	^false! !!GdsDataStructure methodsFor: 'testing' stamp: 'kf 5/18/2009 13:36'!isNullVector	^false! !!GdsDataStructure methodsFor: 'testing' stamp: 'kf 5/26/2009 11:26'!isScalar	^false! !!GdsDataStructure methodsFor: 'testing' stamp: 'kf 5/28/2009 15:49'!sameAsInteger	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsDataStructure class	instanceVariableNames: ''!!GdsDataStructure class methodsFor: 'accessing' stamp: 'kf 4/27/2009 15:32'!acceptRegexPattern	self subclassResponsibility.! !!GdsDataStructure class methodsFor: 'accessing' stamp: 'kf 4/26/2009 11:52'!mode	^self subclassResponsibility! !!GdsDataStructure class methodsFor: 'accessing' stamp: 'kf 11/10/2008 16:04'!rank	^self  subclassResponsibility.! !!GdsDataStructure class methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:10'!shape	self subclassResponsibility.! !!GdsDataStructure class methodsFor: 'test' stamp: 'kf 4/27/2009 15:34'!acceptableExpression: aString	^(aString matchesRegex: self acceptRegexPattern)! !!GdsDataStructure class methodsFor: 'test' stamp: 'kf 5/23/2009 13:55'!isAcceptableSmalltalkObject: anObject	^self subclassResponsibility ! !!GdsDataStructure class methodsFor: 'instance creation' stamp: 'kf 5/23/2009 17:03'!cantConvertSmalltalkObject: anObject	^self error: 'CAN''T CREATE FROM Smalltalk Object: ', anObject printString.	! !!GdsDataStructure class methodsFor: 'instance creation' stamp: 'kf 5/27/2009 16:03'!fromLiteral: aString	(self acceptableExpression: (aString asString))		ifFalse: [	     self syntaxError: 'ILLIGAL LITERAL FORMAT'].	^self new stringValue: aString.	! !!GdsDataStructure class methodsFor: 'instance creation' stamp: 'kf 4/26/2009 11:53'!fromSmalltalk: aObject	^self subclassResponsibility.	! !!GdsDataStructure class methodsFor: 'instance creation' stamp: 'kf 5/23/2009 17:03'!fromSmalltalkObject: anObject	(self isAcceptableSmalltalkObject: anObject)		ifFalse: [^self cantConvertSmalltalkObject: anObject].	^self fromSmalltalk: anObject.	! !GdsDataStructure subclass: #GdsArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Data'!!GdsArray methodsFor: 'arithmetic' stamp: 'kf 5/27/2009 16:33'!applySymbol: aSymbol to: aObject 	| col |	self applySymbolCheck: aSymbol to: aObject.	self assert: [self isScalar not].		((aObject isMemberOf: GdsVector) or: [(aObject isMemberOf: GdsMatrix) ])		ifTrue: 			[self size = aObject size ifFalse: [^self runtimeError: 'ILLIGAL DATA SIZE'].			col := OrderedCollection new.			self elements doWithIndex: 					[:value :index | 					col add: ((value perform: aSymbol with: (aObject at: index)))].			^ GdsVector withAll: col].	^ GdsVector withAll: (self elements 				collect: [:value | (value perform: aSymbol with: aObject)])! !!GdsArray methodsFor: 'convert' stamp: 'kf 5/23/2009 23:17'!asGdsFloating	^ self vectorClass withAll: (self elements collect: [:v | v asGdsFloating])! !!GdsArray methodsFor: 'error handling' stamp: 'kf 5/23/2009 23:32'!doesNotUnderstand: aMessage	"Transcript cr; show: aMessage."	^self newElementSelector: aMessage selector.! !!GdsArray methodsFor: 'private' stamp: 'kf 5/23/2009 23:21'!newElementSelector: aSelector 	^ self vectorClass withAll: (self elements collect: [:v | v perform: aSelector])! !!GdsArray methodsFor: 'testing' stamp: 'kf 5/28/2009 15:49'!sameAsInteger	^ self asVector elements allSatisfy: [:v | v sameAsInteger]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsArray class	instanceVariableNames: ''!GdsDataStructure subclass: #GdsList	instanceVariableNames: 'elements'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Data'!!GdsList commentStamp: 'kf 5/25/2009 20:19' prior: 0!A GdsList is GDSII's LIST data structure.Instance Variables	elements:		<GdsDataStructure>elements	- xxxxx!!GdsList methodsFor: 'initialize-release' stamp: 'kf 5/23/2009 19:31'!add: aGdsDataStructure 	self assert: (aGdsDataStructure isKindOf: GdsDataStructure).	(aGdsDataStructure isMemberOf: GdsList) 		ifTrue: [aGdsDataStructure elements do: [:each | elements add: each]]		ifFalse: [elements add: aGdsDataStructure]! !!GdsList methodsFor: 'initialize-release' stamp: 'kf 5/20/2009 21:32'!initialize	elements := OrderedCollection new.	! !!GdsList methodsFor: 'convert' stamp: 'kf 5/27/2009 16:31'!asVector	^self runtimeError: 'ILLIGAL DATA MODE'.! !!GdsList methodsFor: 'convert' stamp: 'kf 5/21/2009 00:29'!displayUnit	^4.	! !!GdsList methodsFor: 'convert' stamp: 'kf 5/21/2009 00:32'!gplString	| numRepeat rem allUnits |	allUnits := OrderedCollection new.	numRepeat := self elements size quo: (self displayUnit).	(0 to: (numRepeat - 1)) do: [:index |		| start |		start := (index * (self displayUnit)) + 1.		allUnits add: (self elements copyFrom: start to:  (start + (self displayUnit) - 1))].	rem := self elements size rem: (self displayUnit).	(rem > 0) ifTrue: [allUnits add: (self elements  last: rem)].	^(allUnits collect: [:each | self gplStringUnit: each]) joinUsing: (String cr, String cr). ! !!GdsList methodsFor: 'convert' stamp: 'kf 5/22/2009 17:41'!gplStringUnit: aCollection	| nRow nCol colWidth mat colStart cols spaceSize |	spaceSize := 2.	nRow := (aCollection collect: [:each | each gplString lines size]) max.	colWidth := aCollection collect: [:each | 		each gplString isEmpty			ifTrue: [0]			ifFalse: [				(each gplString lines 					collect: [:each2 | each2 size]) max]].	nCol := colWidth sum + ((aCollection size * spaceSize) - 1).	mat := Matrix rows: nRow columns: nCol element: Character space.	colStart := 1.	aCollection doWithIndex: [:each :index| 		| lines iCol  |		lines := each gplString lines.		lines doWithIndex: [:each2 :index2 |			iCol := colStart.	  		each2 asArray do: [:ch |				mat at: index2 at: iCol put: ch.				iCol := iCol + 1.].].		colStart := colStart + (colWidth at: index) + spaceSize.].	cols := OrderedCollection new.	(1 to: mat rowCount)  do: [:index | cols add: (String withAll: (mat atRow: index)) ].	^cols joinUsing: String cr.! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/27/2009 17:04'!at: anIndex	((1 to: self elements size) includes: anIndex)		ifFalse: [^self runtimeError: 'SUBSCRIPT OUT OF BOUNDS'].	^self elements at: anIndex.! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/25/2009 15:03'!atPutUsage	^'Only: [{Integer}] := {Array}'.				! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/27/2009 17:02'!atSubscript: aGdsDataStructure	| indexes list |	(aGdsDataStructure asVector size = 1)		ifFalse: [^self runtimeError: 'ILLIGAL DATA RANK. List subscription only scalar value'].	indexes := self indexesOfSubscript: aGdsDataStructure.	list := self class withAll: (self indexedValues: indexes).	^list length = 1 ifTrue: [list at: 1] ifFalse: [list].! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/25/2009 23:07'!atSubscript: aSubscript put: aGdsValue	| index |	"subscipt := self subscriptArgumentCheck:  aSubscript."	(aGdsValue isKindOf: GdsList)		ifTrue: [^self error: self atPutUsage ].	index := aSubscript asSmalltalkValue.	((1 to: elements size) includes: index) 		ifFalse: [^self error: 'SUBSCRIPT OUT OF RANGE'].	elements at: index put: aGdsValue.					! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/20/2009 21:53'!elements	^elements asArray.! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/20/2009 22:14'!length	^self elements size.! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/27/2009 17:02'!rank	^self runtimeError: 'ILLIGAL DATA MODE'.! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/27/2009 16:12'!shape	^self runtimeError: 'ILLIGAL DATA MODE'.! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/27/2009 16:12'!size	^self runtimeError: 'ILLIGAL DATA MODE'.! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/25/2009 23:36'!subscriptCheckForAssign:  aSubscript	| subscipt |	subscipt := aSubscript.	(aSubscript isMemberOf: GdsVector)		ifTrue: [aSubscript size = 1			ifTrue: [subscipt := aSubscript at: 1]			ifFalse: [^self error: self atPutUsage ]].	(aSubscript isKindOf: GdsScalar)		ifFalse: [^self error: self atPutUsage ].	(subscipt isKindOf: GdsIntegral)		ifFalse: [^self error: self atPutUsage ].	^self subscriptCheckFor: subscipt			! !!GdsList methodsFor: 'accessing' stamp: 'kf 5/25/2009 20:53'!typeString	^'LIST'! !!GdsList methodsFor: 'testing' stamp: 'kf 6/11/2009 17:49'!isList	^true! !!GdsList methodsFor: 'printing' stamp: 'kf 5/20/2009 22:13'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	self elements do: [:each | 		aStream nextPutAll: each gplSourceString.		aStream nextPut: $;.].	aStream skip: -1.	aStream nextPutAll: ')'.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsList class	instanceVariableNames: ''!!GdsList class methodsFor: 'accessing' stamp: 'kf 11/10/2008 16:10'!mode	^6! !!GdsList class methodsFor: 'instance creation' stamp: 'kf 5/22/2009 23:33'!withAll: aGplValues	| newInstance |	newInstance := self new.	aGplValues do: [:each | newInstance add: each copy].	^newInstance! !GdsArray subclass: #GdsMatrix	instanceVariableNames: 'stMatrix'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Data'!!GdsMatrix commentStamp: 'kf 5/21/2009 13:24' prior: 0!A GdsDataMatrix is GPLII's Matrix.Instance Variables	stMatrix:		<Matrix<GdsDglType>>stMatrix	- sclar elements Smallk's value holder !!GdsMatrix methodsFor: 'arithmetic' stamp: 'kf 6/7/2009 17:50'!applySymbol: aSymbol to: aObject 	| target calcedVec |	self applySymbolCheck: aSymbol to: aObject.	self assert: [self isScalar not].	target := aObject.	((aObject isKindOf: GdsScalar) or: [aObject isMemberOf: GdsMatrix]) 		ifTrue: [			target := aObject asVector: self size ]		ifFalse: [			(self shape = aObject shape)				ifFalse: [^self error: 'INVALID SHAPE ']].	calcedVec := self asVector applySymbol: aSymbol to: target.	^self  fromGdsVector: calcedVec! !!GdsMatrix methodsFor: 'convert' stamp: 'kf 5/26/2009 15:21'!asGdsFloating	^ self fromGdsVector:  super asGdsFloating! !!GdsMatrix methodsFor: 'convert' stamp: 'kf 5/23/2009 22:48'!asVector	^ self vectorClass withAll: stMatrix contents copy! !!GdsMatrix methodsFor: 'convert' stamp: 'kf 5/23/2009 19:31'!gplValueOfShape	^ GdsVector withAll: { 				(GdsInteger fromLiteral: stMatrix rowCount).				(GdsInteger fromLiteral: stMatrix columnCount)}! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 6/10/2009 16:25'!at: aInteger	^[self asVector at: aInteger] on: Error do: [:ex |		self runtimeError: 'SUBSCRIPTION OUT OF RANGE'].! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/23/2009 22:38'!at: rowIndex at: columnIndex	^stMatrix at: rowIndex at: columnIndex! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/25/2009 23:05'!atSubscript: aSubscript 	| mat result |	"self subscriptArgumentCheck: aSubscript."	mat := self subscriptMatrix: aSubscript.	(mat rowCount = 1 and: [mat columnCount = 1]) 		ifTrue: [^ (mat at: 1 at: 1) copy].	(mat rowCount = 1 and: [mat columnCount ~= 1]) 		ifTrue: [^ self vectorClass withAll: (mat atRow: 1)].	(mat rowCount ~= 1 and: [mat columnCount = 1]) 		ifTrue: [^ self vectorClass withAll: (mat atColumn: 1)].	result := self class new.	result instVarNamed: 'stMatrix' put: mat copy.	^ result! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/25/2009 23:05'!atSubscript: aSubscript put: aGdsValue	| mat  pair pairs reshapedValue |	"self subscriptArgumentCheck: aSubscript."	mat := self subscriptIndexMatrix: aSubscript.	reshapedValue := aGdsValue.	(mat rowCount = 1 and: [mat columnCount = 1]) 		ifTrue: [			(aGdsValue isKindOf: GdsScalar)				ifFalse: [self error: 'ONLY: [r;c] := {Scalar}']. 			pair :=mat at: 1 at: 1.			stMatrix at: pair first at: pair second put: aGdsValue copy.			^aGdsValue].					(mat rowCount = 1 and: [mat columnCount ~= 1]) 		ifTrue: [			(aGdsValue isKindOf: GdsScalar)				ifTrue: [reshapedValue := aGdsValue asVector: stMatrix columnCount ].			(reshapedValue isKindOf: GdsVector)				ifFalse: [^self error: 'ONLY: [r; ] := {Vector}']. 			(reshapedValue size = stMatrix columnCount)				ifFalse: [^self error: 'VECTOR SIZE MUST: ', stMatrix columnCount asString, ' BUT: ', reshapedValue size asString].			pairs :=mat atRow: 1.			pairs do: [:each |				stMatrix 					atRow: each first					put: (reshapedValue elements)].				^aGdsValue].				(mat rowCount ~= 1 and: [mat columnCount = 1]) 		ifTrue: [			(aGdsValue isKindOf: GdsScalar)				ifTrue: [reshapedValue := aGdsValue asVector: stMatrix rowCount].			(reshapedValue isKindOf: GdsVector)				ifFalse: [^self error: 'ONLY: [;c] := {Vector}']. 			(reshapedValue size = stMatrix rowCount)				ifFalse: [^self error: 'VECTOR SIZE MUST: ', stMatrix rowCount asString, ' BUT: ', aGdsValue size asString].			pairs :=mat atColumn: 1.			pairs do: [:each |				stMatrix 					atColumn: each second					put: (reshapedValue elements )].				^aGdsValue].	(aGdsValue isKindOf: GdsScalar)		ifTrue: [			reshapedValue := GdsMatrix				fromGdsVector: aGdsValue  row: mat rowCount  col: mat columnCount.].	((Array with: mat rowCount with: mat columnCount)  = aGdsValue shape)		ifFalse: [^self error: 'SUBSCRIPT SHAPE MISS MATCH MUST: '].	(1 to: mat rowCount) do: [:ri |		(1 to: mat columnCount) do: [:ci |			pair :=mat at: ri at: ci.			stMatrix at: pair first at: pair second put: (reshapedValue at: ri at: ci) copy].].	^ aGdsValue! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/22/2009 23:58'!columnCount	^stMatrix columnCount! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/23/2009 18:02'!elements	^stMatrix readStream contents asArray.! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 9/16/2009 16:12'!gplString	(self typeString beginsWith: 'REAL')		ifTrue: [^self gplStringFloating].	^self gplStringNonFloating ! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/19/2009 00:46'!mode	stMatrix  ifNil: [^GdsNull mode].	stMatrix asOrderedCollection ifEmpty: [^GdsNull mode].	^stMatrix asOrderedCollection first mode! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/22/2009 23:58'!rowCount	^stMatrix rowCount! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/19/2009 01:15'!shape	^Array with: stMatrix rowCount with: stMatrix columnCount! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/19/2009 01:13'!size	^stMatrix size! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/25/2009 23:52'!subscriptCheckFor: aSubscript 	(aSubscript isMemberOf: GdsList) 		ifFalse: [^ self error: 'ILLIGAL SUBSCRIPT ACCESS. only [row;col]'].	aSubscript length = 2 		ifFalse: [^ self error: 'ILLIGAL SUBSCRIPT ACCESS. only [row;col]'].	super subscriptCheckFor: (aSubscript at: 1).	super subscriptCheckFor: (aSubscript at: 2).	^aSubscript! !!GdsMatrix methodsFor: 'accessing' stamp: 'kf 5/19/2009 14:44'!typeString	stMatrix  ifNil: [^GdsNull typeString].	stMatrix asOrderedCollection ifEmpty: [^GdsNull typeString].	^stMatrix asOrderedCollection first typeString! !!GdsMatrix methodsFor: 'instance creation' stamp: 'kf 5/26/2009 15:20'!fromGdsScalar: aGdsScalar	self assert: [(aGdsScalar isKindOf: GdsScalar)].	^self class 			fromGdsVector: (aGdsScalar asVector: self size) 			row: self rowCount			col: self columnCount.	! !!GdsMatrix methodsFor: 'instance creation' stamp: 'kf 6/12/2009 09:10'!fromGdsVector: aGdsVector	self assert: [(aGdsVector isMemberOf: GdsVector) or: [aGdsVector isCharVector]].	^self class 			fromGdsVector: (aGdsVector) 			row: self rowCount			col: self columnCount.	! !!GdsMatrix methodsFor: 'private' stamp: 'kf 5/23/2009 19:31'!gplStringFloating	| maxWidths strings |	(stMatrix contents anySatisfy: [:each | each gplString includes: $E]) 		ifTrue: [^ self gplStringNonFloating].	maxWidths := self maxGplStringWidthPair.	strings := OrderedCollection new.	1 to: stMatrix rowCount		do: 			[:index | 			strings add: (GdsVector 						gplStringValues: (stMatrix atRow: index)						paddLeftWidth: maxWidths first						rightWidth: maxWidths second)].	^ strings joinUsing: String cr! !!GdsMatrix methodsFor: 'private' stamp: 'kf 5/23/2009 19:31'!gplStringNonFloating	| strings maxWidth |	maxWidth := self maxGplStringWidth.	strings := OrderedCollection new.	1 to: stMatrix rowCount		do: 			[:index | 			strings 				add: (GdsVector gplStringValues: (stMatrix atRow: index) paddWidth: maxWidth)].	^ strings joinUsing: String cr! !!GdsMatrix methodsFor: 'private' stamp: 'kf 5/23/2009 21:43'!indexesOf: aGdsDataStructure at: aIndex	| indexes gplValue ranges outRanges |	ranges := (1 to: (aIndex = 1 ifTrue: [self rowCount] ifFalse: [self columnCount])). 	indexes := ranges asArray.			gplValue := aGdsDataStructure at: aIndex.	gplValue rank = 0		ifTrue: [			indexes := Array with: gplValue asSmalltalkValue.].	(gplValue rank = 1 and: [gplValue ~= GdsNull instance])		ifTrue: [			indexes := gplValue asSmalltalkValue].	outRanges := (indexes reject: [:each | ranges includes: each ]).	outRanges isEmpty ifFalse: [^self error: 'SUBSCRIPT OUT OF RANGE ', outRanges printString].	^indexes.	! !!GdsMatrix methodsFor: 'private' stamp: 'kf 5/20/2009 15:21'!maxGplStringWidth	^(stMatrix contents collect: [:each | each gplString size]) max! !!GdsMatrix methodsFor: 'private' stamp: 'kf 5/20/2009 17:23'!maxGplStringWidthPair	"{ leftWidth . rightWidth }" 	| leftMax rightMax |	leftMax := 0.	rightMax := 0.	stMatrix contents do: [:each |		| s items| 		s := each gplString.		items := { s copyFrom: 1 to: (s indexOf: $.) - 1 . s copyFrom: (s indexOf: $.) + 1 to: (s size) }.		leftMax := leftMax max: (items first size).		rightMax := rightMax max: (items second size).].	^Array with:  leftMax with: rightMax! !!GdsMatrix methodsFor: 'private' stamp: 'kf 6/7/2009 17:57'!newElementSelector: aSelector 	| gdsArray |	gdsArray := super newElementSelector: aSelector.	^self class fromGdsVector: gdsArray row: self rowCount col: self columnCount! !!GdsMatrix methodsFor: 'private' stamp: 'kf 5/23/2009 20:47'!subscriptIndexMatrix: aGdsDataStructure	| rowIndexes columnIndexes  mat |	rowIndexes := self indexesOf: aGdsDataStructure at: 1.	columnIndexes := self indexesOf: aGdsDataStructure at: 2.	mat := Matrix rows: rowIndexes size columns: columnIndexes size.	rowIndexes doWithIndex: [:ra :ri |		columnIndexes doWithIndex: [:ca :ci |			mat at: ri at: ci  put: (Array with: ra with: ca).]].	^mat.	! !!GdsMatrix methodsFor: 'private' stamp: 'kf 5/23/2009 00:44'!subscriptMatrix: aGdsDataStructure	| rowIndexes columnIndexes  mat |	rowIndexes := self indexesOf: aGdsDataStructure at: 1.	columnIndexes := self indexesOf: aGdsDataStructure at: 2.	mat := Matrix rows: rowIndexes size columns: columnIndexes size.	rowIndexes doWithIndex: [:ra :ri |		columnIndexes doWithIndex: [:ca :ci |			mat at: ri at: ci  put: (stMatrix at: ra at: ca).]].	^mat.	! !!GdsMatrix methodsFor: 'printing' stamp: 'kf 5/23/2009 19:31'!printOn: aStream 	super printOn: aStream.	aStream nextPut: $(.	(1 to: stMatrix rowCount) do: 			[:index | 			aStream nextPut: $[.			aStream nextPutAll: (GdsVector gplStringValues: (stMatrix atRow: index)).			aStream nextPut: $].			aStream nextPut: $,].	aStream skip: -1.	aStream nextPut: $)! !!GdsMatrix methodsFor: 'initialize-release' stamp: 'kf 5/18/2009 22:50'!rows: rows columns: columns contents: anArray	stMatrix := Matrix rows: rows columns: columns contents: anArray.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsMatrix class	instanceVariableNames: ''!!GdsMatrix class methodsFor: 'as yet unclassified' stamp: 'kf 5/19/2009 00:29'!fromGdsVector: aGdsDataVector col: aColCount 	^self fromGdsVector: aGdsDataVector  row: 1 col: aColCount! !!GdsMatrix class methodsFor: 'as yet unclassified' stamp: 'kf 5/19/2009 00:27'!fromGdsVector: aGdsDataVector row: aRowCount col: aColCount 	| size fillSize appends total fillCount vector |	vector := aGdsDataVector asVector.	size := aColCount * aRowCount.	fillSize := 0.	total := OrderedCollection new.	appends := #().	(vector size < size )		ifTrue: [			fillSize := size rem: vector size.			fillCount := size quo: vector size.			fillCount timesRepeat: [total addAll: vector elements].			appends := fillSize > 0 				ifTrue: [					vector copyFrom: 1 to: fillSize] ifFalse: [appends]]		ifFalse: [total addAll: (vector copyFrom: 1 to: size)].	total addAll: appends.	^self new rows: aRowCount columns: aColCount contents: total.		! !!GdsMatrix class methodsFor: 'as yet unclassified' stamp: 'kf 5/30/2009 09:58'!fromOrigin: anOrigin corner: aCorner	| gplVec |	gplVec := {anOrigin x . anOrigin y . aCorner x . aCorner y} asGdsValue.	^GdsMatrix fromGdsVector: gplVec  row: 2 col: 2. ! !!GdsMatrix class methodsFor: 'as yet unclassified' stamp: 'kf 5/30/2009 10:03'!fromRectangle: aRectangle	^self fromOrigin: aRectangle  origin corner: aRectangle corner! !!GdsMatrix class methodsFor: 'accessing' stamp: 'kf 4/26/2009 11:51'!rank	^2! !GdsArray subclass: #GdsScalar	instanceVariableNames: 'stringValue'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Data'!!GdsScalar commentStamp: 'kf 5/21/2009 13:22' prior: 0!A GdsDataScalar is GPLII's Scalar.Instance Variables	stringValue:		<ByteSyting>stringValue	- GPLII literal expression.!!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:24'!abs	^self newRealSelector: #abs! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:33'!arcTan	^self newRealBlock: [self asFloat arcTan radiansToDegrees].! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:24'!ceiling	^self newRealSelector: #ceiling! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:30'!cos	^self newRealBlock: [self asFloat degreesToRadians cos].! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:30'!exp	^self newRealSelector: #exp! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:30'!floor	^self newRealSelector: #floor! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:25'!ln	^self newRealSelector: #ln! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:32'!not	^self newIntegerBlock: [self asFloat isZero ifTrue: [-1] ifFalse: [0]].! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:41'!pi	^self newRealBlock: [self asFloat * Float pi].! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:31'!sin	^self newRealBlock: [self asFloat degreesToRadians sin]! !!GdsScalar methodsFor: 'math function' stamp: 'kf 4/27/2009 00:31'!tan	^self newRealBlock: [self asFloat degreesToRadians tan].! !!GdsScalar methodsFor: 'private' stamp: 'kf 6/10/2009 16:36'!applySmalltalkValueSymbol: aSymbol to: aObject 	| leftValue |	(aObject isScalar not) 		ifTrue: [			leftValue := self asVector: aObject size.			(aObject isKindOf: GdsMatrix)				ifTrue: [leftValue := 					GdsMatrix 						fromGdsVector: leftValue 						row: aObject rowCount						col: aObject columnCount].			^ leftValue perform: aSymbol with: aObject].	^ self asFloat perform: (aSymbol = #% ifTrue: [#/] ifFalse: [aSymbol])		with: aObject asFloat! !!GdsScalar methodsFor: 'private' stamp: 'kf 5/26/2009 15:00'!applySymbol: aSymbol to: aObject 	self applySymbolCheck: aSymbol to: aObject.	^(self applySmalltalkValueSymbol: aSymbol  to:  aObject)		asGdsValue! !!GdsScalar methodsFor: 'private' stamp: 'kf 4/27/2009 17:15'!newIntegerBlock: aBlock	^GdsInteger fromLiteral: (aBlock value asInteger).	! !!GdsScalar methodsFor: 'private' stamp: 'kf 4/27/2009 17:15'!newIntegerSelector: aSelector	^GdsInteger fromLiteral: (self asFloat perform: aSelector) asInteger.	! !!GdsScalar methodsFor: 'private' stamp: 'kf 4/27/2009 17:40'!newRealBlock: aBlock	^GdsReal new stringValue: (aBlock value asFloat).	! !!GdsScalar methodsFor: 'private' stamp: 'kf 4/27/2009 17:14'!newRealSelector: aSelector	^GdsReal fromLiteral: (self asFloat perform: aSelector) asFloat.	! !!GdsScalar methodsFor: 'converting' stamp: 'kf 4/25/2009 14:57'!asFloat	^self asSmalltalkValue asFloat! !!GdsScalar methodsFor: 'converting' stamp: 'kf 4/27/2009 17:10'!asGdsFloating	^ GdsReal fromLiteral: self asFloat. ! !!GdsScalar methodsFor: 'converting' stamp: 'kf 5/26/2009 15:30'!asVector	^ self vectorClass withAll: (Array with: self)! !!GdsScalar methodsFor: 'converting' stamp: 'kf 5/26/2009 15:31'!asVector: aSize 	^ self vectorClass withAll: (Array new: aSize withAll: self)! !!GdsScalar methodsFor: 'converting' stamp: 'kf 4/27/2009 00:21'!negated	^self newRealSelector: #negated.	! !!GdsScalar methodsFor: 'converting' stamp: 'kf 4/27/2009 00:22'!reciprocal	^self newRealSelector: #reciprocal.! !!GdsScalar methodsFor: 'converting' stamp: 'kf 5/26/2009 10:59'!sign	^self newRealSelector: #sign.! !!GdsScalar methodsFor: 'accessing' stamp: 'kf 5/22/2009 23:30'!at: aIndex	^self error: 'ILIIGAL ACCESS FOR SCALAR []'.! !!GdsScalar methodsFor: 'accessing' stamp: 'kf 5/27/2009 16:38'!atSubscript: aSubscript	^self subscriptCheckForReturn: aSubscript! !!GdsScalar methodsFor: 'accessing' stamp: 'kf 5/27/2009 16:38'!atSubscript: aSubscript put: aGdsValue	^self subscriptCheckForAssign: aSubscript! !!GdsScalar methodsFor: 'accessing' stamp: 'kf 5/26/2009 11:23'!elements	^Array with: self.! !!GdsScalar methodsFor: 'accessing' stamp: 'kf 5/19/2009 01:49'!gplValueOfShape	^GdsNull instance! !!GdsScalar methodsFor: 'accessing' stamp: 'kf 4/27/2009 21:36'!size	^1	! !!GdsScalar methodsFor: 'accessing' stamp: 'kf 4/24/2009 18:01'!stringValue	^stringValue asString! !!GdsScalar methodsFor: 'accessing' stamp: 'kf 4/21/2009 20:35'!stringValue: aGplExpression	stringValue := aGplExpression.	! !!GdsScalar methodsFor: 'accessing' stamp: 'kf 5/27/2009 16:38'!subscriptCheckFor: aGdsDataStructure	^self runtimeError: 'CAN''T  SUBSCRIPTION ACCESS TO SCALAR VALUE '! !!GdsScalar methodsFor: 'testing' stamp: 'kf 5/26/2009 11:26'!isScalar	^true! !!GdsScalar methodsFor: 'testing' stamp: 'kf 4/26/2009 23:35'!negative	^self asFloat negative! !!GdsScalar methodsFor: 'testing' stamp: 'kf 5/28/2009 15:52'!sameAsInteger	^self asSmalltalkValue asFloat fractionPart = 0.0! !!GdsScalar methodsFor: 'testing' stamp: 'kf 4/26/2009 23:35'!strictlyPositive	^self asFloat strictlyPositive! !!GdsScalar methodsFor: 'printing' stamp: 'kf 4/24/2009 00:19'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	aStream nextPutAll: self gplString.	aStream nextPutAll: ')'.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsScalar class	instanceVariableNames: ''!!GdsScalar class methodsFor: 'as yet unclassified' stamp: 'kf 11/10/2008 16:04'!rank	^0! !!GdsScalar class methodsFor: 'as yet unclassified' stamp: 'kf 5/19/2009 01:48'!shape	^GdsNull instance! !GdsArray subclass: #GdsVector	instanceVariableNames: 'values'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Data'!!GdsVector commentStamp: 'kf 5/19/2009 14:34' prior: 0!A GdsDataVector is GPLII's Vector.Instance Variables	values:		<Array<GdsDglType>>values	- xxxxx!!GdsVector methodsFor: 'adding' stamp: 'kf 4/23/2009 23:49'!add: aGdsDataStructure	self assert: (aGdsDataStructure isKindOf: GdsDataStructure)	     description: 'Only GdsDataStructure'.	values ifNil: [values := OrderedCollection new.].	values add: aGdsDataStructure.! !!GdsVector methodsFor: 'convert' stamp: 'kf 5/22/2009 23:51'!asSmalltalkValue	^(self elements collect: [:each | each asSmalltalkValue copy]) asArray.! !!GdsVector methodsFor: 'convert' stamp: 'kf 4/24/2009 17:51'!asVector	^self	! !!GdsVector methodsFor: 'convert' stamp: 'kf 4/24/2009 00:34'!gplString	^String streamContents: [:s | self printGplOn: s]	! !!GdsVector methodsFor: 'accessing' stamp: 'kf 5/27/2009 16:32'!at: aInteger	^[values at: aInteger] on: Error do: [:ex |		self runtimeError: 'SUBSCRIPTION OUT OF RANGE'].! !!GdsVector methodsFor: 'accessing' stamp: 'kf 5/21/2009 23:46'!at: aInteger put: aGplValue	values at: aInteger put: aGplValue.! !!GdsVector methodsFor: 'accessing' stamp: 'kf 5/22/2009 23:42'!atSubscript: aGdsDataStructure	| indexes vec |	indexes := self indexesOfSubscript: aGdsDataStructure.	vec := self class withAll: (self indexedValues: indexes).	^vec size = 1 ifTrue: [vec at: 1] ifFalse: [vec].	! !!GdsVector methodsFor: 'accessing' stamp: 'kf 5/23/2009 19:51'!atSubscript: aSubscript put: aGdsValue	| subscripts |	(aSubscript isMemberOf: GdsList) 		ifTrue: [^ self notSupportMatrixSubscription].	(aGdsValue isKindOf: GdsScalar) 		ifFalse: [^ self error: 'CAN''T ASSIGN NON SCALAR VALUE.'].	subscripts := aSubscript asVector.	subscripts elements 		do: [:each | self at: each asSmalltalkValue put: aGdsValue].	^ aGdsValue! !!GdsVector methodsFor: 'accessing' stamp: 'kf 5/18/2009 22:59'!copyFrom: from to: to	^values copyFrom: from to: to.! !!GdsVector methodsFor: 'accessing' stamp: 'kf 5/18/2009 23:02'!elements	^values asArray.! !!GdsVector methodsFor: 'accessing' stamp: 'kf 4/26/2009 12:28'!mode	values ifNil: [^GdsNull mode].	values ifEmpty: [^GdsNull mode].	^values first mode! !!GdsVector methodsFor: 'accessing' stamp: 'kf 5/19/2009 01:50'!shape	^self size.! !!GdsVector methodsFor: 'accessing' stamp: 'kf 4/24/2009 14:45'!size	values ifNil: [^0].	^values size.! !!GdsVector methodsFor: 'accessing' stamp: 'kf 4/24/2009 13:48'!typeString	values ifNil: [^GdsNull typeString].	values ifEmpty: [^GdsNull typeString].		^values first typeString! !!GdsVector methodsFor: 'copying' stamp: 'kf 5/23/2009 23:27'!copyValues	| newValues |	newValues := values collect: [:each | each copy].	values := OrderedCollection new.	values addAll: newValues.		! !!GdsVector methodsFor: 'printing' stamp: 'kf 5/19/2009 00:00'!printGplOn: aStream	aStream nextPutAll: (self class gplStringValues: values).		! !!GdsVector methodsFor: 'printing' stamp: 'kf 5/18/2009 23:57'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	self printGplOn: aStream.	aStream nextPutAll: ')'.		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsVector class	instanceVariableNames: ''!!GdsVector class methodsFor: 'instance creation' stamp: 'kf 5/27/2009 16:20'!fromLiteral: aGplExpr	| exprs clazz gValues |	exprs := aGplExpr findTokens: ' '.	gValues := exprs collect: [:each | 		clazz := GdsDglType bestClassOfStatement: each.		clazz ifNil: [self syntaxError: 'ILLIGAL LITERAL: ', each].		clazz fromLiteral: each].	^self withAll: gValues.! !!GdsVector class methodsFor: 'instance creation' stamp: 'kf 5/23/2009 15:17'!fromSmalltalk: anObject	^self withAll: (anObject collect: [:each | each asGdsValue])! !!GdsVector class methodsFor: 'instance creation' stamp: 'kf 5/23/2009 14:17'!withAll: aGplValues	| modes maxMode upperClazz vec |	modes := aGplValues collect: [:gValue | gValue mode].	(modes asSet size = 1)		ifTrue: [			vec := self new.			aGplValues do: [: elm | vec add: elm].			^vec]. 	maxMode := modes max.	upperClazz := GdsDglType instanciateClasses detect: [:clazz | clazz mode = maxMode ].	vec := self new.	aGplValues do: [: elm | 		vec add: (upperClazz fromLiteral: (elm gplString))].	^vec.! !!GdsVector class methodsFor: 'printing' stamp: 'kf 5/19/2009 00:00'!gplStringValues: aCollection	^(aCollection collect: [:elm | elm gplString]) joinUsing: ' '.		! !!GdsVector class methodsFor: 'printing' stamp: 'kf 5/20/2009 17:01'!gplStringValues: aCollection paddLeftWidth: aWidth	^(aCollection collect: [:elm | elm gplString padded: #left to: aWidth with: Character space ]) joinUsing: ' '.		! !!GdsVector class methodsFor: 'printing' stamp: 'kf 5/20/2009 17:03'!gplStringValues: aCollection paddLeftWidth: aLeftWidth rightWidth: aRightWidth	^(aCollection collect: [:elm | 		elm gplStringLeftWidth: aLeftWidth rightWidth: aRightWidth]) joinUsing: ' '.		! !!GdsVector class methodsFor: 'printing' stamp: 'kf 5/20/2009 15:25'!gplStringValues: aCollection paddWidth: aWidth	^(aCollection collect: [:elm | elm gplString padded: #left to: aWidth with: Character space ]) joinUsing: ' '.		! !!GdsVector class methodsFor: 'testing' stamp: 'kf 5/23/2009 14:00'!isAcceptableSmalltalkObject: anObject	(anObject isKindOf: Collection) ifFalse: [^false].	anObject ifEmpty: [^false].	^anObject allSatisfy: [:each |  GdsNumber isAcceptableSmalltalkObject: each ].	! !!GdsVector class methodsFor: 'accessing' stamp: 'kf 4/26/2009 11:51'!rank	^1	! !GdsVector subclass: #GdsNull	instanceVariableNames: ''	classVariableNames: 'Singleton'	poolDictionaries: ''	category: 'GdsCompiler-Data'!!GdsNull commentStamp: 'kf 4/28/2009 00:58' prior: 0!A GdsNull is empty vector.instance represents ""but not a character vector.like as lisp's empty list.TYPEOF ""=> NULLRANK ""=> 1  is a vector. not sclar!!GdsNull methodsFor: 'accessing' stamp: 'kf 5/26/2009 14:48'!applySymbol: aSymbol to: aObject 	^self illigalDataMode.! !!GdsNull methodsFor: 'accessing' stamp: 'kf 5/27/2009 16:51'!atSubscript: aGdsDataStructure	^self runtimeError: 'ILLIGAL ACCESS FOR NULL VECTOR []'.! !!GdsNull methodsFor: 'accessing' stamp: 'kf 5/19/2009 13:59'!shape	^#() copy.! !!GdsNull methodsFor: 'accessing' stamp: 'kf 4/27/2009 21:36'!size	^0! !!GdsNull methodsFor: 'convert' stamp: 'kf 5/19/2009 14:37'!asSmalltalkValue	^#() copy	! !!GdsNull methodsFor: 'convert' stamp: 'kf 5/20/2009 22:12'!gplSourceString	^'""'! !!GdsNull methodsFor: 'convert' stamp: 'kf 4/26/2009 11:41'!gplString	^''! !!GdsNull methodsFor: 'copying' stamp: 'kf 5/23/2009 23:28'!copy	^self.! !!GdsNull methodsFor: 'testing' stamp: 'kf 5/18/2009 13:37'!isNullVector	^true! !!GdsNull methodsFor: 'testing' stamp: 'kf 5/28/2009 15:49'!sameAsInteger	^ false! !!GdsNull methodsFor: 'printing' stamp: 'kf 4/26/2009 15:03'!printOn: aStream	aStream nextPutAll: 'a GdsNull'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsNull class	instanceVariableNames: ''!!GdsNull class methodsFor: 'accessing' stamp: 'kf 4/28/2009 01:01'!acceptRegexPattern	^'""'! !!GdsNull class methodsFor: 'accessing' stamp: 'kf 5/27/2009 16:04'!fromLiteral: aString	(self acceptableExpression: (aString asString))		ifFalse: [	     self syntaxError: 'ILLIGAL LITERAL FORMAT'].	^self instance.	! !!GdsNull class methodsFor: 'accessing' stamp: 'kf 11/10/2008 16:53'!instance	Singleton ifNil: [Singleton := GdsNull new.].	^Singleton	! !!GdsNull class methodsFor: 'accessing' stamp: 'kf 11/10/2008 16:46'!mode	^5! !!GdsNull class methodsFor: 'accessing' stamp: 'kf 5/19/2009 13:59'!shape	^#()	! !!GdsNull class methodsFor: 'accessing' stamp: 'kf 4/24/2009 13:48'!typeString	^'NULL'! !!GdsNull class methodsFor: 'instance creation' stamp: 'kf 5/23/2009 14:30'!fromSmalltalk: aObject	^GdsNull instance.! !!GdsNull class methodsFor: 'test' stamp: 'kf 5/23/2009 14:29'!isAcceptableSmalltalkObject: anObject	(anObject isKindOf: Collection) ifFalse: [^false].	^anObject isEmpty! !GdsVector subclass: #GdsString	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Data'!!GdsString commentStamp: 'kf 5/19/2009 14:34' prior: 0!A GdsString is special case of DataVector.CHARACTER VECTOR Data type on GDSII.Inherited Instance Variables	values:		<Array<GdsCharacter>>!!GdsString methodsFor: 'convert' stamp: 'kf 5/26/2009 14:48'!applySymbol: aSymbol to: aObject 	^self illigalDataMode.! !!GdsString methodsFor: 'convert' stamp: 'kf 5/20/2009 22:13'!gplSourceString	^'"',self gplString, '"'! !!GdsString methodsFor: 'testing' stamp: 'kf 6/12/2009 08:48'!isCharVector	^true! !!GdsString methodsFor: 'testing' stamp: 'kf 5/28/2009 15:49'!sameAsInteger	^ false! !!GdsString methodsFor: 'printing' stamp: 'kf 4/26/2009 15:57'!printGplOn: aStream	aStream nextPutAll: ((values collect: [:elm | elm gplString]) joinUsing: '').! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsString class	instanceVariableNames: ''!!GdsString class methodsFor: 'test' stamp: 'kf 5/27/2009 17:07'!acceptRegexPattern	^'".*"'! !!GdsString class methodsFor: 'test' stamp: 'kf 5/23/2009 14:24'!isAcceptableSmalltalkObject: anObject	(anObject isKindOf: Collection) ifFalse: [^false].	anObject ifEmpty: [^false].	^anObject allSatisfy: [:each | GdsCharacter isAcceptableSmalltalkObject: each ].! !!GdsString class methodsFor: 'instance creation' stamp: 'kf 5/27/2009 16:50'!fromLiteral: aString	| realContents |	(aString isByteString) ifFalse: [^self syntaxError: 'STRING NOT OCTET VALUE.'].	(aString size >= 2) ifFalse: [^self syntaxError: 'STRING NOT QUOTED.'].		(aString first = $" and: [aString last = $"])		ifFalse: [^self syntaxError: 'STRING NOT QUOTED.'].	aString = '""' ifTrue: [^GdsNull instance].	realContents := 	aString copyFrom: 2 to: aString size - 1.	^self fromSmalltalkString: realContents.	! !!GdsString class methodsFor: 'instance creation' stamp: 'kf 5/23/2009 15:10'!fromSmalltalk: anObject	^self fromSmalltalkString: anObject.	! !!GdsString class methodsFor: 'instance creation' stamp: 'kf 9/15/2012 19:59'!fromSmalltalkString: aString	| s msg c level markBuff resultBuff handled asciiValue|	s := aString readStream.	markBuff := WriteStream on: (String new).	resultBuff := WriteStream on: (String new).	msg := 'Character embed code mismatch <>'.	level := 0.	[s atEnd]		whileFalse: [			c := s next.			handled := false.			c = $<				ifTrue: [					level = 0 ifFalse: [^self syntaxError: msg].					level := level + 1.					handled := true].			c = $>				ifTrue: [					level = 1 ifFalse: [^self syntaxError: msg].					level := level - 1.					handled := true].			(handled not and:[level = 1])				ifTrue: [					markBuff nextPut: c.					handled := true].			(handled not and:[level = 0])				ifTrue: [					resultBuff nextPut: c.					handled := true].			(s atEnd or: [c = $>])				ifTrue: [					markBuff contents 						ifNotEmpty: [ 							"Transcript cr show: {aString . markBuff contents}."							asciiValue := GdsCharacter asciiValueInsideCharMarkLiteral: markBuff contents.							(asciiValue isKindOf: Integer)								ifTrue: [									resultBuff nextPut: (Character value: asciiValue).].							markBuff reset].].				].		level = 0 ifFalse: [^self syntaxError: msg].				^self  fromAsciiValues: resultBuff contents asByteArray asArray.		! !!GdsString class methodsFor: 'private' stamp: 'kf 9/15/2012 15:00'!fromAsciiValues: asciiValues 	| elements |	elements := asciiValues collect: [:asciiValue | 		GdsCharacter fromAsciiValue: asciiValue ].	^self withAll: elements.		! !