Model subclass: #GdsLibrary	instanceVariableNames: 'structures nameMap station unitString libname databaseUnit archivePath meterUnit lastModified lastAccessed layers kinds'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Container'!!GdsLibrary commentStamp: 'kf 10/21/2009 15:27' prior: 0!A GdsLibrary is xxxxxxxxx.Instance Variables	nameMap:		<Dictionary<String,GdsStructure>>	station:		<GdsStation>	structures:		<Array<GdsStructure>>	lastModified:	<DateAndTime>	lastAccessed:  <DateAndTime>nameMap	- fast lookup structure instance by structure name.station	- reference to Application Model instance.structures	- holds structures instance !!GdsLibrary methodsFor: 'structure control' stamp: 'kf 10/22/2009 16:19'!addStructure: aGdsStructure	structures add: aGdsStructure.	nameMap ifNil: [nameMap := Dictionary new.].	nameMap at: aGdsStructure name put: aGdsStructure.	aGdsStructure database: self.! !!GdsLibrary methodsFor: 'structure control' stamp: 'kf 6/16/2009 22:50'!elementClass	^GdsStructure	! !!GdsLibrary methodsFor: 'structure control' stamp: 'kf 6/16/2009 22:51'!newStructureNamed: aStructureName	| s |	(self hasStructureName: aStructureName)		ifTrue: [self error: 'structure name: ', aStructureName printString, 'already exists'].	s := self elementClass new setName: aStructureName database: self.	self addStructure: s.	^s.	! !!GdsLibrary methodsFor: 'structure control' stamp: 'kf 11/6/2008 12:21'!removeStructure: aGdsStructure	structures remove: aGdsStructure.	nameMap ifNotNil: [nameMap removeKey: aGdsStructure name ifAbsent: [].].	! !!GdsLibrary methodsFor: 'structure control' stamp: 'kf 10/20/2008 20:48'!structureNamed: aString	^self structures detect: [:each | each name sameAs: aString ] ifNone:[].! !!GdsLibrary methodsFor: 'structure control' stamp: 'kf 10/20/2008 20:46'!structureNames	^self structures collect: [:each | each name].! !!GdsLibrary methodsFor: 'private' stamp: 'kf 6/22/2009 14:00'!archivePath: aPathToDatabase	archivePath := aPathToDatabase.	! !!GdsLibrary methodsFor: 'private' stamp: 'kf 6/17/2009 15:29'!deleteFileDirectoryBlock: aBlock	| extractedFd |	extractedFd := aBlock value.	(self class exists: self libNameWithExtension)		ifFalse: [^self].	extractedFd recursiveDelete.	self assert: [extractedFd exists not].! !!GdsLibrary methodsFor: 'private' stamp: 'kf 6/17/2009 15:30'!deleteWorkFolder	self deleteFileDirectoryBlock: [self fileDirectoryForWork].! !!GdsLibrary methodsFor: 'private' stamp: 'kf 6/17/2009 17:01'!fileDirectoryForEdit	| fd folderName |	self assert: [self libName isNil not].	fd := self class fileDirectoryForExtract .	fd assureExistence.	folderName := self libNameWithExtension.	^FileDirectory on: (fd fullPathFor: folderName).	! !!GdsLibrary methodsFor: 'private' stamp: 'kf 6/17/2009 14:31'!fileDirectoryForWork	^self fileDirectoryForEdit.! !!GdsLibrary methodsFor: 'private' stamp: 'kf 6/15/2009 13:43'!libInfoAsIniOn: aIniStream 	| iniFile |	iniFile := GdsIniFile  new.	iniFile 		section: 'INITLIB'		at: 'name'		put: self libName.	iniFile 		section: 'INITLIB'		at: 'dbu'		put: self databaseUnit asString.	iniFile 		section: 'INITLIB'		at: 'unit'		put: self unitString.	iniFile writeOn: aIniStream.! !!GdsLibrary methodsFor: 'private' stamp: 'kf 11/18/2009 17:04'!lookupUsingLayerNumbers	^(Array streamContents: [:s |		self structures do: [:struc |			s nextPutAll: struc lookupUsingLayerNumbers]		]) asSet asSortedArray.! !!GdsLibrary methodsFor: 'private' stamp: 'kf 6/18/2009 15:04'!makeArchive	| archive |	(FileDirectory default fileExists: self zipedPath)		ifTrue: [FileDirectory deleteFilePath: self zipedPath  ].	archive := ZipArchive new.	archive addTree: self fileDirectoryForEdit removingFirstCharacters: self fileDirectoryForEdit pathName size + 1.	[ archive writeToFileNamed: self zipedPath ] on: Error do: [ :ex | self inform: ex description. ].	archive close.	! !!GdsLibrary methodsFor: 'private' stamp: 'kf 11/8/2009 20:39'!makeFolder	| newFd stream |	newFd := self fileDirectoryForEdit.	newFd assureExistence.			stream := nil.		[stream := newFd newFileNamed: self class libInfoFileName.	self libInfoAsIniOn: stream] 			ensure: [stream ifNotNil: [stream close]]! !!GdsLibrary methodsFor: 'private' stamp: 'kf 6/16/2009 14:38'!zipedPath	| savePathFd |	savePathFd := self class fileDirectoryForLocalName: self libNameWithExtension .	^savePathFd pathName.! !!GdsLibrary methodsFor: 'as yet unclassified' stamp: 'kf 11/8/2009 20:47'!close	self isOpen ifFalse: [^self].	self saveLayers.	self makeArchive.	self deleteWorkFolder.! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 6/12/2009 15:39'!databaseUnit	^databaseUnit 	! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 6/12/2009 15:39'!databaseUnit: aInteger	databaseUnit := aInteger.	! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 12/8/2009 13:51'!kinds	kinds ifNil: [kinds := GdsKinds new].	^kinds! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 10/21/2009 15:26'!lastAccessed: aDateAndTime	lastAccessed := aDateAndTime.	! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 10/21/2009 15:26'!lastModified: aDateAndTime	lastModified := aDateAndTime.	! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 11/8/2009 21:14'!layers	layers ifNil: [layers := GdsLayers new].	^layers! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 6/22/2009 15:46'!libName	libname ifNotNil:  [^libname].	archivePath 		ifNotNil: [			^self class baseName: (FileDirectory localNameFor: archivePath)].	^libname	! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 6/17/2009 15:29'!libName: aString	libname ifNotNil: [^self error: 'LIBRARY NAME ASSIGNED ONCE'].	GdsLibrary checkLibName: aString.	libname := self class baseName: aString.! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 6/12/2009 16:13'!libNameWithExtension	^self libName, self class extension.	! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 10/21/2009 14:02'!meterUnit	^meterUnit	! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 10/21/2009 14:02'!meterUnit: aFloat	meterUnit := aFloat.	! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 6/13/2009 14:15'!privateLibName: aString	libname := self class baseName: aString.! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 11/10/2008 13:50'!station	^station! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 11/10/2008 13:46'!station: aGdsStation	station := aGdsStation.! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 5/12/2009 14:14'!structureNamesForReference	self assert: self structure isNil not.	^(self structureNames reject: [:name | self structure name sameAs: name]) asArray.! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 9/19/2008 18:34'!structures	^structures asArray.! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 6/12/2009 16:24'!unitString	^unitString! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 6/12/2009 12:32'!unitString: aString	self class checkUnitString: aString.	unitString := aString asUppercase.! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 10/21/2009 14:01'!userUnit	^self databaseUnit reciprocal asFloat.! !!GdsLibrary methodsFor: 'accessing' stamp: 'kf 10/21/2009 14:01'!userUnit: aFloat	self databaseUnit: aFloat reciprocal asInteger.! !!GdsLibrary methodsFor: 'defaults' stamp: 'kf 6/12/2009 15:41'!defaultDatabaseUnit	^1000	! !!GdsLibrary methodsFor: 'defaults' stamp: 'kf 6/12/2009 15:40'!defaultUnitString	^'MICRON'	! !!GdsLibrary methodsFor: 'testing' stamp: 'kf 6/22/2009 16:52'!dirty	^self structures anySatisfy: [:each | each dirty].! !!GdsLibrary methodsFor: 'testing' stamp: 'kf 6/8/2009 17:10'!hasStructureName: aStructureName	^(self structures select: [ :s | s name sameAs: aStructureName ]) isEmpty not.! !!GdsLibrary methodsFor: 'testing' stamp: 'kf 6/22/2009 14:05'!isOpen	^self fileDirectoryForEdit exists.! !!GdsLibrary methodsFor: 'testing' stamp: 'kf 6/16/2009 22:48'!isTransient	^ false! !!GdsLibrary methodsFor: 'initialization' stamp: 'kf 12/8/2009 13:51'!initialize	super initialize.	structures := OrderedCollection new.	unitString := nil.	layers := GdsLayers new.	kinds := GdsKinds new.	! !!GdsLibrary methodsFor: 'initialization' stamp: 'kf 6/17/2009 14:50'!name: aLibName databaseUnit: aInteger unitString: aUnitString	self privateName: aLibName databaseUnit:  aInteger unitString: aUnitString.	self makeArchive.	self deleteWorkFolder.	! !!GdsLibrary methodsFor: 'initialization' stamp: 'kf 6/17/2009 14:49'!privateName: aLibName databaseUnit: aInteger unitString: aUnitString	self libName: aLibName.	self databaseUnit: aInteger.	self unitString: aUnitString.	self makeFolder.	! !!GdsLibrary methodsFor: 'initialization' stamp: 'kf 10/31/2009 20:39'!release	structures ifNotNil: [structures do: [:each | each release]].	structures := nil.	nameMap := nil.	station := nil.	super release.! !!GdsLibrary methodsFor: 'objects from disk' stamp: 'kf 11/8/2009 21:18'!loadLayers	| pathToXml |	pathToXml := self fileDirectoryForEdit fullNameFor: self localNameForLayers .	(FileDirectory default fileExists: pathToXml)		ifFalse: [^self].	GdsFeel 		xmlDocumentFromPath: pathToXml 		documentBlock: [:xmlDocument |			self layers loadFromXmlDocument: xmlDocument]! !!GdsLibrary methodsFor: 'objects from disk' stamp: 'kf 6/23/2009 10:46'!loadLibInfo	| stream map |	stream := nil.		 [stream := self fileDirectoryForEdit readOnlyFileNamed: 'LIB.ini'.	 map := self class libInfoFromIni: stream.]		ensure: [stream ifNotNil: [stream close.]].	[self privateLibName: (map at: 'name'). 	self databaseUnit: (map at: 'dbu') asInteger.	self unitString: (map at: 'unit')] 		on: Error		do:  [:ex | 			^self error: 'LIBRARY INFO FORMAT ERROR'].	! !!GdsLibrary methodsFor: 'objects from disk' stamp: 'kf 6/18/2009 15:16'!loadStructures	| fd |	fd := self fileDirectoryForEdit.	fd assureExistence.	Cursor wait showWhile: [self loadStructures: fd].! !!GdsLibrary methodsFor: 'objects from disk' stamp: 'kf 10/28/2009 11:34'!loadStructures: aFileDirectory 	| names |	names := aFileDirectory directoryNames select: [:each | each endsWith: '.structure'].	names := names 				select: [:name | GdsCompatibility default isValidStructureName: (FileDirectory baseNameFor: name)].	names do: 			[:each | 			| name structure |			name := FileDirectory baseNameFor: each.			name := (name findTokens: '.') first. 			structure := self newStructureNamed: name.			[structure load] on: Error				do: 					[:ex | 					Transcript						cr;						show: (String streamContents: 										[:s | 										s nextPutAll: '***ERROR***'.										s nextPutAll: ' '.										s nextPutAll: 'skip broken structure: '.										s nextPutAll: name]).					self removeStructure: structure]]! !!GdsLibrary methodsFor: 'objects from disk' stamp: 'kf 11/8/2009 21:09'!localNameForLayers	^'layers.xml'.! !!GdsLibrary methodsFor: 'objects from disk' stamp: 'kf 11/8/2009 20:49'!open	self isOpen ifTrue: [^self].	self class extract: self libName.	self loadLibInfo.	self loadLayers.	self loadStructures.	! !!GdsLibrary methodsFor: 'objects from disk' stamp: 'kf 11/8/2009 21:10'!saveLayers	GdsFeel 		fileOutXmlTopElement: self layers asXmlElement 		fileDirectory: self fileDirectoryForEdit  localName: self localNameForLayers.! !!GdsLibrary methodsFor: 'printing' stamp: 'kf 6/12/2009 16:07'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self libName.		aStream nextPut: $).	! !!GdsLibrary methodsFor: '*GdsFeel-Morphic-Extension' stamp: 'kf 11/4/2009 14:05'!fileDirectoryForThumbnails	| fd folderName |	self assert: [self libName isNil not].	folderName := self libNameWithExtension.	fd := self class fileDirectoryForThumbnailExtract: folderName  .	fd assureExistence.	^fd		! !!GdsLibrary methodsFor: 'utility' stamp: 'kf 11/24/2009 10:46'!autoAllocateLayerColors	| numbers layer colorStream |	numbers := self lookupUsingLayerNumbers.	colorStream := ReadStream on: (Color wheel: numbers size saturation: 0.7 brightness: 1.0).	numbers do: [:each | 		layer := self layers atNumber: each.		layer color: colorStream next].			! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsLibrary class	instanceVariableNames: ''!!GdsLibrary class methodsFor: 'as yet unclassified' stamp: 'kf 10/1/2008 22:27'!exampleEmptyInstance	| db struct |	db := GdsLibrary new.	struct := db newStructureNamed: 'MAIN'.	^db! !!GdsLibrary class methodsFor: 'as yet unclassified' stamp: 'kf 10/1/2008 22:27'!exampleInstance	| db struct |	db := GdsLibrary new.	struct := db newStructureNamed: 'MAIN'.	struct fillExampleInstance .	^db! !!GdsLibrary class methodsFor: 'as yet unclassified' stamp: 'kf 6/15/2009 20:57'!fileDirectoryForExtract	^self fileDirectoryForExtract: nil.	! !!GdsLibrary class methodsFor: 'as yet unclassified' stamp: 'kf 11/4/2009 13:56'!fileDirectoryForExtract: aLocalName	^self fileDirectorySubDirectoryNamed: '.editlibs' forExtract: aLocalName	! !!GdsLibrary class methodsFor: 'as yet unclassified' stamp: 'kf 6/22/2009 14:48'!fileDirectoryForLocalName: aLocalName	| fd |	fd := self fileDirectory.	fd assureExistence.	^FileDirectory on: (fd fullPathFor: aLocalName).! !!GdsLibrary class methodsFor: 'as yet unclassified' stamp: 'kf 11/4/2009 13:55'!fileDirectorySubDirectoryNamed: aSubDirName forExtract: aLocalName	| fd |	fd := self fileDirectoryForLocalName: aSubDirName.	fd assureExistence.	^aLocalName 		ifNil: [fd]		ifNotNil: [FileDirectory on: (fd fullPathFor: aLocalName)].	! !!GdsLibrary class methodsFor: 'instance creation' stamp: 'kf 6/22/2009 14:58'!all	^self filePaths collect: [:each | self fromDbPath: each].! !!GdsLibrary class methodsFor: 'instance creation' stamp: 'kf 10/23/2008 17:26'!betaInstance	^self new loadBetaStructures! !!GdsLibrary class methodsFor: 'instance creation' stamp: 'kf 10/22/2009 16:52'!extract: aLibName	| archivedSpaceFd zipPath archiver extractedFd |	archivedSpaceFd := GdsFeel fileDirectory.	zipPath := archivedSpaceFd fullNameFor: (self dbName: aLibName).	self assert: [archivedSpaceFd fileExists: zipPath].	(ZipArchive isZipArchive: zipPath)		ifFalse: [^self error: ('DATABASE FORMAT ERROR {1}' format: {zipPath})].	archiver := ZipArchive new.	archiver readFrom: zipPath.	self makeWorkDirectory: aLibName.	extractedFd := GdsLibrary fileDirectoryForExtract: (self dbName: aLibName).	archiver extractAllTo: extractedFd .	archiver close.	^extractedFd.		! !!GdsLibrary class methodsFor: 'instance creation' stamp: 'kf 6/22/2009 15:17'!fromDbPath: aPathToDatabase	^self new archivePath: aPathToDatabase.! !!GdsLibrary class methodsFor: 'instance creation' stamp: 'kf 6/16/2009 21:15'!initializeName: aString databaseUnits: anInteger unitString: aUnitString 	self checkLibName: aString.	self checkDatabaseUnit: anInteger.	self checkUnitString: aUnitString.	^GdsLibrary new		name: aString databaseUnit: anInteger unitString: aUnitString.! !!GdsLibrary class methodsFor: 'instance creation' stamp: 'kf 10/22/2009 16:52'!makeWorkDirectory: aLibName	(GdsLibrary fileDirectoryForExtract)		createDirectory:  (self dbName: aLibName).		! !!GdsLibrary class methodsFor: 'instance creation' stamp: 'kf 6/16/2009 16:36'!openNamed: aLibName	| tLibName fullDbName fd stream map lib extractedFd |	tLibName := self  baseName: aLibName.	fullDbName := (tLibName, self  extension).	fd := self  fileDirectoryForExtract.	(fd directoryExists: fullDbName)		ifTrue: [^self error: ('LIBRARY ALREADY OPEND {1}' format: {tLibName} )].  	(self exists: fullDbName)		ifFalse: [^self error: ('LIBRARY NOT FOUND {1}' format: {tLibName} )].  			extractedFd := self extract: aLibName.			stream := nil.		 [stream := extractedFd readOnlyFileNamed: 'LIB.ini'.	 map := self libInfoFromIni: stream.]		ensure: [stream ifNotNil: [stream close.]].	lib := GdsLibrary new.	[lib privateLibName: (map at: 'name'). 	lib databaseUnit: (map at: 'dbu') asInteger.	lib unitString: (map at: 'unit')] 		on: Error		do:  [:ex | 			^self error: 'LIBRARY INFO FORMAT ERROR'].	^lib	! !!GdsLibrary class methodsFor: 'instance creation' stamp: 'kf 6/23/2009 13:26'!storagePathDbNamed: aLibName	| tLibName fullDbName |	tLibName := self  baseName: aLibName.	fullDbName := (tLibName, self  extension).	^self  fileDirectoryForExtract fullNameFor: fullDbName.	! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/22/2009 16:27'!archivedNames	^((self fileDirectory) fileNamesMatching: self extensionBasicMatchExpr ) 		reject: [:each | (each sameAs: 'Thumbs.db') 			or: [(self isValidDbPath: (self fileDirectory fullNameFor: each)) not]]! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/12/2009 11:06'!baseName: aString	^((aString endsWith: self extension)		ifTrue: [aString  allButLast: self extension size]		ifFalse: [aString]) asUppercase! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/12/2009 11:33'!baseNames	^ self names collect: [:each | self baseName: each ].! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/16/2009 13:53'!dbName: aString	^((aString endsWith: self extension)		ifTrue: [aString]		ifFalse: [aString, self extension]) asUppercase! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/12/2009 11:25'!exists: aString	| checkName |	checkName := self baseName: aString.	^self baseNames anySatisfy: [:each | each sameAs: checkName] ! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/22/2009 14:46'!extractedNames	^((self fileDirectory) directoryNames 		select: [:each | 			(each endsWith: self extension)]) ! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/22/2009 14:46'!fileDirectory	^GdsFeel fileDirectory! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/22/2009 15:15'!filePaths	| fullPaths |	fullPaths := (GdsLibrary fileDirectory fileNamesMatching: '*.DB')		collect: [:each | 			GdsLibrary fileDirectory fullNameFor: each].	^fullPaths select: [:each | GdsLibrary isValidDbPath: each].! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/12/2009 10:36'!names	^ self archivedNames , self extractedNames! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 10/21/2009 14:19'!unitSpec	^{		#('M' 1.0) . 		#('CM' 1.0e-2) . 		#('MM' 1.0e-3). 		#('MICRON' 1.0e-6) . 		#('INCH' 2.54e-2). 		#('MIL' 2.54e-3) 	}! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 10/21/2009 14:23'!unitStrings	^self unitSpec collect: [:each | each first].! !!GdsLibrary class methodsFor: 'accessing' stamp: 'kf 6/12/2009 10:08'!unitsString	^(self unitStrings joinUsing: $, asString)! !!GdsLibrary class methodsFor: 'check' stamp: 'kf 6/12/2009 13:11'!checkDatabaseUnit: aNumber	aNumber < 10 ifTrue: [^self error: 'DBU LEAST 10'].	! !!GdsLibrary class methodsFor: 'check' stamp: 'kf 6/22/2009 15:14'!checkLibName: aString	| libnameSizeRange checkName |	checkName := self baseName: aString.	GdsCompatibility default libNameMax > 0		ifTrue: [			libnameSizeRange := 1 to: GdsCompatibility default libNameMax.			(libnameSizeRange includes: checkName size)				ifFalse: [					^self error: ('LIBRARYNAME SIZE UNDER {1} ' 						format: {libnameSizeRange max})]].	(GdsCompatibility default isValidLibraryName: checkName)		ifFalse: [self error: 'LIBRARY NAME ERROR'].	"(self exists: checkName)		ifTrue: [			^self error: ('LIBNAME ALREADY EXISTS: {1}' format: {checkName})]."! !!GdsLibrary class methodsFor: 'check' stamp: 'kf 6/12/2009 10:10'!checkUnitString: aString	(self  unitStrings includes: aString asUppercase)		ifFalse: [^self error: ('UNITS ONLY {1}' format: {self unitsString })].	! !!GdsLibrary class methodsFor: 'testing' stamp: 'kf 8/13/2009 15:09'!existsBaseName: aBaseName	^(self baseNames detect: [:each | each sameAs: aBaseName] ifNone: [nil]) isNil not.! !!GdsLibrary class methodsFor: 'testing' stamp: 'kf 6/22/2009 14:37'!hasMemberNamed: aZipMemberName archivePath: aPathToDatabase	| members |	members := self privateZipMembersOf: aPathToDatabase.	members ifEmpty: [^false].	^members includes: aZipMemberName! !!GdsLibrary class methodsFor: 'testing' stamp: 'kf 6/22/2009 14:49'!isValidDbPath: aPathToDatabase	| filePart directoryPart |	filePart := FileDirectory localNameFor: aPathToDatabase.	directoryPart := FileDirectory dirPathFor: aPathToDatabase.	((FileDirectory on: directoryPart) fileExists: filePart)		ifFalse: [^false].	(directoryPart sameAs: GdsFeel pathToSelf)		ifFalse: [			"current impelments one directory "			^false].	[self checkLibName: filePart] on: Error do: [:ex | ^false].	^self hasMemberNamed: self libInfoFileName archivePath: aPathToDatabase! !!GdsLibrary class methodsFor: 'testing' stamp: 'kf 6/22/2009 16:41'!privateZipMembersOf: aPathToDatabase	| zipArchive result |	result := #().	zipArchive := ZipArchive new.	[zipArchive readFrom: aPathToDatabase.	result := zipArchive memberNames]		on: Error do: [: ex | ].	zipArchive close.		^result.		! !!GdsLibrary class methodsFor: 'constants' stamp: 'kf 6/12/2009 10:40'!extension	^'.' , self extensionBody ! !!GdsLibrary class methodsFor: 'constants' stamp: 'kf 6/12/2009 10:42'!extensionBasicMatchExpr	^'*', self extension.! !!GdsLibrary class methodsFor: 'constants' stamp: 'kf 6/12/2009 10:39'!extensionBody	^'DB'! !!GdsLibrary class methodsFor: 'constants' stamp: 'kf 6/22/2009 14:47'!libInfoFileName	^'LIB.ini'! !!GdsLibrary class methodsFor: 'private' stamp: 'kf 6/15/2009 13:51'!libInfoFromIni: aIniStream	| iniFile |	iniFile := GdsIniFile readFrom: aIniStream.	^(iniFile section: 'INITLIB')					  ! !!GdsLibrary class methodsFor: 'private' stamp: 'kf 6/15/2009 13:33'!libInfoFromIniOrig: aIniStream	| map |	map := self libInfoMapFromIni: aIniStream.	({ 'name' . 'dbu' . 'unit'}		anySatisfy: [:each | (map includesKey: each) not])		ifTrue: [^self error: 'LIBRARY INFO FORMAT ERROR'].	({ 'name' . 'dbu' . 'unit'}		anySatisfy: [:each | (map at: each ifAbsent: [nil]) isNil])		ifTrue: [^self error: 'LIBRARY INFO FORMAT ERROR'].	^map.					  ! !!GdsLibrary class methodsFor: 'private' stamp: 'kf 6/12/2009 17:15'!libInfoMapFromIni: aIniStream	| map line sepIndex key value |	map := Dictionary new.	[aIniStream atEnd]		whileFalse: [			line := aIniStream  upToAll: String crlf.			sepIndex := line indexOf: $=.			sepIndex > 0				ifTrue: [					key := line copyFrom: 1 to: sepIndex - 1.					value := line copyFrom: sepIndex + 1 to: line size.					map at: key put: value]].	^map.					  ! !!GdsLibrary class methodsFor: 'maintenance' stamp: 'kf 6/17/2009 22:32'!upgrade	"GdsLibrary upgrade"	(FileDirectory default directoryExists:  GdsFeel pathToBeta)		ifFalse: [^self inform: 'Don''t need Upgrade'].			Cursor wait 		showWhile: [Smalltalk garbageCollect].	GdsLibrary allInstances 		ifNotEmpty: [			^self inform: 'Can''t upgradeGdsStationUI still opend.close GdsStationUI morpc window andwaiting soon or restart Squeak Virtual Image'].	Cursor wait showWhile: [		GdsFeel rebuild.		self upgradeBetaFolder].		! !!GdsLibrary class methodsFor: 'maintenance' stamp: 'kf 6/17/2009 14:21'!upgradeBetaFolder	| station |	self assert: [(FileDirectory default directoryExists:  GdsFeel pathToBeta)].	station := GdsStation new.	station openBetaLibrary.	station closeBetaLibrary.		! !!GdsLibrary class methodsFor: '*GdsFeel-Morphic-Extension' stamp: 'kf 11/4/2009 14:09'!fileDirectoryForThumbnailExtract: aLocalName	^self fileDirectorySubDirectoryNamed: '.session' forExtract: aLocalName	! !Model subclass: #GdsStation	instanceVariableNames: 'library structure items idContext'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Container'!!GdsStation commentStamp: 'kf 11/12/2008 11:40' prior: 0!A GdsStation is xxxxxxxxx.Instance Variables	items:		<GdsItems>	library:		<GdsLibrary>	structure:		<GdsStructure>items	- xxxxxlibrary	- xxxxxstructure	- xxxxx!!GdsStation methodsFor: 'command-handler' stamp: 'kf 10/22/2008 14:20'!assertNilDependent	self assert: [(self dependents includes: nil) not].	! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 6/18/2009 10:38'!bstructEnabled	library ifNil: [^false].	structure ifNotNil: [^false].	^true.! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 5/3/2009 17:20'!bstructName: aBlockOrString	self newStructureNamed: aBlockOrString.	^self.	! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 10/8/2009 10:02'!initlibNamed: name databaseUnits: dbu unitString: unit	| lib |	lib := GdsLibrary initializeName: name databaseUnits: dbu unitString: unit.	lib ifNotNil: [self changed: #openlibEnabled].	^lib! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 10/8/2009 09:59'!initlibNamed: name unitString: unit	^self initlibNamed: name databaseUnits: 1000 unitString: unit ! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 11/4/2009 16:10'!openStructureNamed: aStructureName 	self openStructureNamed: aStructureName ifAbsentCreate: false! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 6/15/2009 17:34'!openStructureNamed: aStructureName ifAbsentCreate: aDoCreate	| struc |	struc := self library structureNamed: aStructureName. 	(struc isNil and: [aDoCreate]) 		ifTrue:  [self bstructName: aStructureName]		ifFalse: [self ostructNames: [:names | aStructureName]].	^self structure.	! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 6/18/2009 11:19'!openlibNames: aNamesArgBlock sortBlock: sortBlock	"aNamesArgBlock must be return library name"	| name names |	self assertNilDependent.	library ifNotNil: [^self error: 'library already opend.'].	structure ifNotNil: [^self error: 'structure already opend.'].	names := (GdsLibrary baseNames asArray sort: sortBlock) collect: [:each | each ].		name := aNamesArgBlock value: names.		name ifNil: [^self].	self openLibraryNamed:  name.! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 6/8/2009 17:12'!ostructEnabled	library ifNil: [^false].	structure ifNotNil: [^false].	^library structures isEmpty not.! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 10/28/2008 14:53'!ostructNames: aNamesArgBlock	^self ostructNames: aNamesArgBlock  sortBlock: [:a :b | a  name <= b name]. ! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 11/4/2009 17:51'!ostructNames: aNamesArgBlock sortBlock: sortBlock	"aNamesArgBlock must be return structure name"	| name names |	"self assertNilDependent."	library ifNil: [^self error: 'no library open.'].	structure ifNotNil: [^self error: 'structure already opend.'].	names := (library structures sort: sortBlock) collect: [:each | each name].		name := aNamesArgBlock value: names.		name ifNil: [^self].	self structure: (library structureNamed: name).! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 5/16/2009 11:15'!tstruct	Cursor wait showWhile: [self closeStructure].		! !!GdsStation methodsFor: 'command-handler' stamp: 'kf 6/22/2009 17:11'!tstructEnabled		structure ifNil: [^false].	^structure closeEnabled.		! !!GdsStation methodsFor: 'action' stamp: 'kf 6/18/2009 11:27'!closeBetaLibrary	library ifNil: [^self].	library closeWithUpdate.	self library: nil.! !!GdsStation methodsFor: 'action' stamp: 'kf 6/18/2009 15:25'!closeLibrary	library ifNil: [^self].	library close.	self library: nil.! !!GdsStation methodsFor: 'action' stamp: 'kf 11/4/2009 16:22'!closeStructure	"self assertNilDependent."	structure ifNil: [^self error: 'structure already closed.'].	structure closeWithSave.	self structure: nil.	! !!GdsStation methodsFor: 'action' stamp: 'kf 6/17/2009 22:49'!openDefault	"self openBetaLibrary"! !!GdsStation methodsFor: 'action' stamp: 'kf 6/23/2009 13:28'!openLibraryNamed: aLibName	| lib |	lib := GdsLibrary fromDbPath: (		 GdsLibrary storagePathDbNamed: aLibName).	self library: lib.	library station: self.	library open.	self structure: nil.	! !!GdsStation methodsFor: 'testing' stamp: 'kf 6/22/2009 17:12'!closeEnabled	structure ifNil: [^true].	^structure closeEnabled! !!GdsStation methodsFor: 'accessing' stamp: 'kf 11/12/2008 13:58'!idSelection	^idContext! !!GdsStation methodsFor: 'accessing' stamp: 'kf 11/10/2008 13:51'!items	^items! !!GdsStation methodsFor: 'accessing' stamp: 'kf 6/22/2009 16:55'!labelString	^String streamContents: [:s |		s nextPutAll: 'GdsFeel: '.		self library 			ifNotNil: [self library dirty ifTrue: [s nextPutAll: '* ']].		s nextPutAll: self labelStringAfter].! !!GdsStation methodsFor: 'accessing' stamp: 'kf 6/22/2009 16:49'!labelStringAfter	library ifNil: [^'NO LIBRARY OPEN'].	structure ifNil: [^'[{1}].NO STRUCTURE OPEN' format: {library libName}].	^'[{1}].[{2}]' format: {library libName . structure name}.! !!GdsStation methodsFor: 'accessing' stamp: 'kf 10/23/2008 15:52'!library	^library.! !!GdsStation methodsFor: 'accessing' stamp: 'kf 6/18/2009 15:22'!library: aGdsLibrary	library ifNotNil: [library removeDependent: self].	library := aGdsLibrary.	aGdsLibrary		ifNil: []		ifNotNil: [			library addDependent: self.			self structure: nil.].	self libraryChanged.		self structureChanged.! !!GdsStation methodsFor: 'accessing' stamp: 'kf 5/3/2009 17:19'!newStructureNamed: aBlockOrString	| name newStructure |	self assertNilDependent.	library ifNil: [^self error: 'no library open.'].	structure ifNotNil: [^self error: 'structure already opend.'].	name := aBlockOrString value.	name ifNil: [^self].	newStructure := library newStructureNamed: name.	self structure: newStructure.	^newStructure! !!GdsStation methodsFor: 'accessing' stamp: 'kf 10/20/2008 16:34'!structure	^structure! !!GdsStation methodsFor: 'accessing' stamp: 'kf 11/13/2009 21:03'!structure: aGdsStructure	self structureWillChange.	structure := aGdsStructure.	aGdsStructure		ifNil: [			self structureDidUnBind]		ifNotNil: [			self structureDidBind.].	"self assert: [self dependents size >= 2]."	self structureChanged.	self libraryChanged.		! !!GdsStation methodsFor: 'accessing' stamp: 'kf 11/13/2009 21:05'!structureDidBind	self assert: [structure notNil].	structure addDependent: self.	items structure: structure.	idContext structure: structure.	items current addDependent: self.	! !!GdsStation methodsFor: 'accessing' stamp: 'kf 11/13/2009 21:01'!structureDidUnBind	items forgetStructure.	idContext forgetStructure	! !!GdsStation methodsFor: 'accessing' stamp: 'kf 11/13/2009 21:05'!structureWillChange	structure ifNotNil: [structure removeDependent: self].	items ifNotNil: [items current removeDependent: self].! !!GdsStation methodsFor: 'initialization' stamp: 'kf 11/12/2008 13:43'!initialize	super initialize.	items := GdsItems new.	idContext := GdsIdContext new.		! !!GdsStation methodsFor: 'initialization' stamp: 'kf 10/31/2009 20:40'!release	items release.	items := nil.	idContext release.	idContext := nil.		super release.		! !!GdsStation methodsFor: 'updating' stamp: 'kf 10/8/2009 10:00'!libraryChanged	self changed: #library.	self changed: #openlibEnabled.	self changed: #closelibEnabled.! !!GdsStation methodsFor: 'updating' stamp: 'kf 10/26/2008 22:05'!structureChanged	self changed: #relabel.	self changed: #structure.			self changed: #ostructEnabled.	self changed: #bstructEnabled.	self changed: #tstructEnabled.		! !!GdsStation methodsFor: 'updating' stamp: 'kf 11/13/2009 21:07'!update: aParameter	aParameter == #tstructEnabled		ifTrue: [			self changed: #tstructEnabled.			self changed: #closelibEnabled].	aParameter == #elementType		ifTrue: [self changed: #elementType].	super update: aParameter.! !!GdsStation methodsFor: 'ui-basics' stamp: 'kf 10/12/2008 23:16'!modelCommandSelector: aSelector	^self modelCommandNamed: aSelector asString asUppercase selector: aSelector.! !!GdsStation methodsFor: 'maintenance' stamp: 'kf 6/18/2009 11:28'!openBetaLibrary	self library: (GdsTransientBetaLibrary new).	library station: self.	library loadStructures.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsStation class	instanceVariableNames: ''!!GdsStation class methodsFor: 'instance creation' stamp: 'kf 6/15/2009 18:01'!openDefault	^self new openDefault.! !Model subclass: #GdsStructure	instanceVariableNames: 'database name colElements dataExtentForElements timeModified timeCreated savedName storagePath dirtyReservedArea dirtyElements maxKeyNumber layers'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Container'!!GdsStructure commentStamp: 'kf 11/12/2008 11:57' prior: 0!A GdsStructure is holdes collection of GdsElement.element member of GdsLibrary.Instance Variables	colElements:		<Array<GdsElement>>	dataExtentForElements:		<Rectangle<Float>>>	database:		<GdsLibrary>	dirtyElements:		<Array<GdsElement>>	dirtyReservedArea:		<Array<GdsElement>>	maxKeyNumber:		<Integer>	name:		<String>	savedName:		<String>	storagePath:		<String>	timeCreated:		<DateAndTime>	timeModified:		<DateAndTime>colElements	- xxxxxdataExtentForElements	- xxxxxdatabase	- xxxxxdirtyElements	- xxxxxdirtyReservedArea	- xxxxxmaxKeyNumber	- xxxxxname	- xxxxxsavedName	- xxxxxstoragePath	- xxxxxtimeCreated	- xxxxxtimeModified	- xxxxx!!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/12/2008 09:47'!addElement: aGdsElement	self addElement: aGdsElement keyNumberFill: aGdsElement keyNumberFilled not.! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 10/30/2009 14:45'!addElement: aGdsElement keyNumberFill: aBoolean	| refLayer |	colElements add: aGdsElement.	dataExtentForElements := nil.	aGdsElement instVarNamed: 'owner' put: self.	aBoolean		ifTrue: [aGdsElement instVarNamed: 'keyNumber' put: self nextKeyNumber].			aGdsElement hasLayer		ifTrue: [			refLayer := layers atNumber: aGdsElement layerNumber.			].	! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 10/3/2008 23:07'!dataExtentForElements	dataExtentForElements ifNil: [dataExtentForElements := self lookupDataExtentForElements ].	^dataExtentForElements.! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 6/8/2009 17:13'!dataExtentForFittingView	self elements isEmpty 		ifTrue: [^self safeNoElementDataExtent.].	^self dataExtentForElements.! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 5/12/2009 14:11'!database	^database! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/6/2009 14:30'!directReferenceElements	^ self  elements select: [:each | each type == #sref or: [each type == #aref] ].! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/8/2008 16:51'!dirty	self removedElements ifNotEmpty: [^true].	dirtyElements ifNil: [^false].	^dirtyElements notEmpty.! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 9/19/2008 21:37'!elements	^colElements asArray.! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/6/2009 15:01'!indirectReferencedStructureNames	^self indirectReferencedStructures collect: [:each | each name]	 ! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/6/2009 14:58'!indirectReferencedStructures	| refs set |	set := Set new.	refs := self referencedStructures.	set addAll: refs.	[refs isEmpty]		whileFalse: [			refs 				do: [:each |					refs := each indirectReferencedStructures.					set addAll: refs]].	^set asArray.			 ! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 12/8/2009 13:54'!kinds	self database ifNil: [^nil].	^self database kinds! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 10/28/2008 20:10'!labelString	^String streamContents: [:s |		self dirty ifTrue: [s nextPutAll: '* '].		s nextPutAll: self name].! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 10/29/2009 09:47'!layers	self libraryLayers ifNotNilDo: [:it | ^it].	^self localLayers.! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 10/29/2009 09:46'!libraryLayers	database ifNil: [^nil].	^database layers! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 7/14/2009 14:10'!liveElements	^self elements reject: [:each | 		each state = #inTrush or: [each damaged]].! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 10/29/2009 09:43'!localLayers	^layers! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/6/2009 15:03'!referenceEnabledStructureNames	| ignoreNames |	ignoreNames := self indirectReferencedStructureNames.	^ self  database structureNames 		reject: [ :each | (each sameAs: self  name) or: [ignoreNames includes: each]]! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/6/2009 14:37'!referencedStructureNames	^self referencedStructures collect: [:each | each name].! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/6/2009 14:36'!referencedStructures	^self database structures 		select: [:each | each directReferenceElements anySatisfy: [:el | el structureName sameAs: self name] ]! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/8/2008 16:26'!removeElement: aGdsElement	colElements remove: aGdsElement.	dataExtentForElements := nil.	"self setDirty: true."	! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 11/8/2008 16:48'!removedElements	^self elements select: [:each | each state = #inTrush].! !!GdsStructure methodsFor: 'accessing' stamp: 'kf 9/20/2008 21:07'!safeNoElementDataExtent	^self class safeNoElementDataExtent! !!GdsStructure methodsFor: 'printing' stamp: 'kf 10/23/2008 16:58'!attributesOn: aDictionary	aDictionary at: 'name' put: self name.	aDictionary at: 'created' put: self timeCreated printString.	aDictionary at: 'modified' put: self timeModified printString.	! !!GdsStructure methodsFor: 'printing' stamp: 'kf 9/19/2008 18:46'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	aStream nextPutAll: self name.	aStream nextPutAll: ')'.	! !!GdsStructure methodsFor: 'printing' stamp: 'kf 10/23/2008 17:52'!timeCreatedForStorage	| fd | 		storagePath ifNil: [^nil].	fd := FileDirectory on: storagePath.	^DateAndTime fromSeconds: (fd directoryEntry creationTime).	! !!GdsStructure methodsFor: 'printing' stamp: 'kf 10/23/2008 17:52'!timeModifiedForStorage	| fd | 		storagePath ifNil: [^nil].	fd := FileDirectory on: storagePath.	^DateAndTime fromSeconds: (fd directoryEntry modificationTime).	! !!GdsStructure methodsFor: 'updating' stamp: 'kf 11/19/2008 00:04'!changedIdGroup	self updateIdState.	self changed: #tstructEnabled.				self changed: #unIdEnabled.	self changed: #idClearEnabled.				self changed: #idDeleteEnabled.				self changed: #idNotEmpty.			! !!GdsStructure methodsFor: 'updating' stamp: 'kf 11/17/2008 14:16'!markDirty	self currentItem holdsElement 		ifTrue: [self pushDirtyReservedArea: self currentItem editElement]		ifFalse: [			self liveElements ifNotEmpty: [				self pushDirtyReservedArea: self liveElements last]].	self changed: #dirty.	! !!GdsStructure methodsFor: 'updating' stamp: 'kf 10/27/2009 11:58'!markDirtySelectors	^#(geometry wipe newElement layer layerNumber width pathtype angle mag sname)! !!GdsStructure methodsFor: 'updating' stamp: 'kf 6/24/2009 17:01'!update: anObject.	GdsFeel ifDebugOn: [:s |		s nextPutAll:  self class printString.		s nextPutAll: ' recieve: '.		s nextPutAll: anObject printString.].	(self markDirtySelectors includes: anObject)		ifTrue: [			self markDirty.			dataExtentForElements := nil.			self changed: #geometry.			self changed].	anObject == #geometry		ifTrue: [			dataExtentForElements := nil.			self changed.].	anObject == #unget		ifTrue: [			self revertDirty].	({ #put . #wipe . #idDelete } includes: anObject)		ifTrue: [			self comitDirty.			self changed: anObject].	anObject == #get		ifTrue: [self changed].	anObject == #id		ifTrue: [			self changedIdGroup.						self changed].	anObject == #tstructEnabled		ifTrue: [self changed: #tstructEnabled].	anObject == self currentItem		ifTrue: [self changed: #geometry].			super update: anObject.! !!GdsStructure methodsFor: 'debug' stamp: 'kf 5/15/2009 14:50'!clonedElements: elements appendOn: aOrderedCollection fromToBlock: aBlock	elements do: [:each |		| cloned |		cloned := each copy.		cloned instVarNamed: 'keyNumber' put: nil.		aBlock value: each value: cloned.		aOrderedCollection add: cloned.]! !!GdsStructure methodsFor: 'debug' stamp: 'kf 10/28/2008 00:02'!findNearestElementByPoint: aPoint	^self findNearestElementByPoint: aPoint elements: self liveElements. ! !!GdsStructure methodsFor: 'debug' stamp: 'kf 7/10/2009 09:51'!findNearestElementByPoint: aPoint elements: filteredElements	| distanceOrderElements insideElements |	filteredElements		ifEmpty: [^nil].	filteredElements size = 1		ifTrue: [^filteredElements first].	insideElements := filteredElements		select: [:each  | each dataBounds containsPoint: aPoint ].		insideElements ifEmpty: [insideElements := filteredElements].		distanceOrderElements := insideElements		sort: [:a :b | (a dist: aPoint) < (b dist: aPoint)].	^distanceOrderElements first.! !!GdsStructure methodsFor: 'debug' stamp: 'kf 5/15/2009 14:38'!idCopyOffset: aPoint	| newElements |	newElements := OrderedCollection new.	self 		clonedElements: self idSelection elements 		appendOn: newElements 		fromToBlock: [:from :to |			to moveRelative: aPoint from: from.].	self idSelection idClear.	newElements do: [:each |		self addElement: each.		self idSelection idAdd: each keyNumber.		self pushDirtyReservedArea: each.].	self comitDirty.		! !!GdsStructure methodsFor: 'debug' stamp: 'kf 11/14/2008 23:19'!idDelete	self idSelection elements do: [:each | 		self pushDirtyReservedArea: each.		each wipe.		self removeElement: each.].! !!GdsStructure methodsFor: 'debug' stamp: 'kf 5/15/2009 14:38'!idMoveOffset: aPoint	self idSelection elements do: [:each | 		each moveRelative: aPoint.		self pushDirtyReservedArea: each].	dataExtentForElements := nil.	self comitDirty.		! !!GdsStructure methodsFor: 'debug' stamp: 'kf 11/18/2008 21:22'!updateIdState	| idKeys colChangedElements|	self idSelection ifNil: [^self].	idKeys := self idSelection keyNumbers.	colChangedElements := OrderedCollection new.	(self liveElements reject: [:each | each state = #inItem])		do: [:each | 			(idKeys includes: each keyNumber)				ifTrue: [						each statusNumber ~= GdsElement inIdStausNumber							ifTrue: [								each statusNumber: GdsElement inIdStausNumber.								colChangedElements add: each] ]				ifFalse: [						each statusNumber = GdsElement inIdStausNumber							ifTrue: [								each statusNumber: GdsElement inDatabaseStausNumber.								colChangedElements add: each]]].	self changed: colChangedElements asArray.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 11/7/2009 22:52'!asXmlElement	| attr elmt |	attr := Dictionary new.	self attributesOn: attr.	elmt := XMLElement 		named: 'structure'		attributes: attr.	self liveElements do: [ :each | elmt addElement: each asXmlElement ].	^elmt.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 11/14/2008 23:22'!close	self items ifNotNil: [self items forgetStructure].	self idSelection ifNotNil: [self idSelection forgetStructure].	dirtyElements := nil.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/23/2009 10:30'!closeDiscard	self closeSaving: false.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/23/2009 10:29'!closeSaving: aBoolean	aBoolean ifTrue: [self save].	self close.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/23/2009 10:30'!closeWithSave	self closeSaving: true.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/16/2009 14:22'!fileDirectory	| libFd folderName |	libFd := database fileDirectoryForEdit.	folderName := self nameWithExtension.	(libFd directoryExists: folderName)		ifFalse: [libFd createDirectory: folderName].	^FileDirectory on: (libFd fullPathFor: folderName).! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/17/2009 14:57'!fileDirectoryForLoad	^self fileDirectory.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/17/2009 14:54'!fileOutAsXml	self fileOutAsXmlNew.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 11/7/2009 23:02'!fileOutAsXmlInto: aFileDirectory localName: aLocalName 	GdsFeel 		fileOutXmlTopElement: self asXmlElement		fileDirectory: aFileDirectory		localName: aLocalName! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/17/2009 14:54'!fileOutAsXmlNew	self fileOutAsXmlInto: (self fileDirectory) localName: self maxRevName.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/17/2009 14:57'!load	| lastPath |	lastPath := self fileDirectoryForLoad fullNameFor: self maxRevName.	self loadBetaFromPath: lastPath.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 11/8/2009 22:21'!loadBetaFromPath: aString	GdsFeel 		xmlDocumentFromPath: aString 		documentBlock: [:doc |			storagePath := aString.			self loadBetaFromXmlDocument: doc].! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 11/18/2008 10:21'!loadBetaFromXmlDocument: aXMLDocument	| structureNode |	structureNode := aXMLDocument firstTagNamed: #structure.	structureNode		elementsDo: [ :node |			| clazz element |			clazz := GdsElement classForType: (node attributes at: 'type').			clazz ifNotNil: [				element := clazz new.				element loadFromXmlNode: node.				element fixGeometryError.								self addElement: element]].	self loadFromAttributes: 	structureNode attributes.			self flushDirtyInfo.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 10/23/2008 17:58'!loadFromAttributes: aDictionary	| iso8601 tempName |		iso8601 := (aDictionary at: 'created' ifAbsent: [self timeCreatedForStorage]) asString.	iso8601		ifNotNil: [timeCreated := DateAndTime fromString: iso8601].	iso8601 := (aDictionary at: 'modified' ifAbsent: [self timeModifiedForStorage]) asString.	iso8601		ifNotNil: [timeModified := DateAndTime fromString: iso8601].			tempName := aDictionary at: 'name' ifAbsent: [].	tempName		ifNotNil: [savedName := tempName].	! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/15/2009 16:44'!maxRevName	| names revs |	names := self fileDirectory fileNamesMatching: (self name, '.*', '.gdsfeelbeta').	revs := names collect: [:each | (each findTokens: '.') second asInteger].	revs ifEmpty: [revs := Array with: 1].	^{self name .  revs max asString .  'gdsfeelbeta'}		joinUsing: '.'.! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/16/2009 23:28'!save	self saveBlock: [self fileOutAsXml].! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/16/2009 23:28'!saveBlock: aBlock	self dirty ifFalse: [^self].	timeModified := DateAndTime now.	aBlock value.	self flushDirtyInfo.	"self setDirty: false.	"! !!GdsStructure methodsFor: 'objects from disk' stamp: 'kf 6/16/2009 23:27'!saveUsingSelector: savingSelector	self dirty ifFalse: [^self].	timeModified := DateAndTime now.	self perform: savingSelector.	self flushDirtyInfo.	"self setDirty: false.	"! !!GdsStructure methodsFor: 'testing' stamp: 'kf 6/22/2009 17:10'!closeEnabled	self currentItem putEnabled ifTrue: [^false].	^self idSelection isEmpty	! !!GdsStructure methodsFor: 'testing' stamp: 'kf 6/16/2009 22:48'!isTransient	^ database isTransient! !!GdsStructure methodsFor: 'private' stamp: 'kf 11/8/2008 17:41'!comitDirty	|element |	element := self popDirtyReservedArea.	element 		ifNotNil: [			dirtyElements ifNil: [dirtyElements := OrderedCollection new].			dirtyElements add: element].	self changed: #dirty.		! !!GdsStructure methodsFor: 'private' stamp: 'kf 11/8/2008 16:30'!flushDirtyInfo	dirtyReservedArea := nil.	dirtyElements := nil.! !!GdsStructure methodsFor: 'private' stamp: 'kf 5/30/2009 21:12'!lookupDataExtentForElements	^self lookupDataExtentForElementsChooserBlock: [:element | true]! !!GdsStructure methodsFor: 'private' stamp: 'kf 5/30/2009 21:11'!lookupDataExtentForElementsChooserBlock: aElementBlock	| bounds |	bounds := GeometryUtils minusBounds.	(self liveElements select: aElementBlock) do: [:e |		bounds := bounds merge: e dataBounds.].	^bounds! !!GdsStructure methodsFor: 'private' stamp: 'kf 10/29/2009 09:41'!lookupUsingLayerNumbers	^(self elements 		select: [:each | each hasLayer] 		thenCollect: [:each | each layerNumber]) asSet asSortedArray.! !!GdsStructure methodsFor: 'private' stamp: 'kf 11/8/2008 15:59'!popDirtyReservedArea	dirtyReservedArea ifNil: [^nil].	dirtyReservedArea ifNotEmpty: [^dirtyReservedArea removeLast].	! !!GdsStructure methodsFor: 'private' stamp: 'kf 11/8/2008 15:55'!pushDirtyReservedArea: aGdsElement.	dirtyReservedArea ifNil: [dirtyReservedArea := OrderedCollection new].	^dirtyReservedArea add: aGdsElement.	! !!GdsStructure methodsFor: 'private' stamp: 'kf 11/8/2008 16:42'!revertDirty	self popDirtyReservedArea.	self changed: #dirty.! !!GdsStructure methodsFor: 'private' stamp: 'kf 10/27/2009 10:14'!usingLayerNumbers	^self lookupUsingLayerNumbers! !!GdsStructure methodsFor: 'edit chanel' stamp: 'kf 11/12/2008 14:20'!currentItem	self items ifNil: [^nil].	^self items current.	! !!GdsStructure methodsFor: 'edit chanel' stamp: 'kf 11/12/2008 13:59'!idSelection	database ifNil:[^nil].	database station ifNil:[^nil].	^database station idSelection.! !!GdsStructure methodsFor: 'edit chanel' stamp: 'kf 11/10/2008 13:53'!items	database ifNil:[^nil].	database station ifNil:[^nil].	^database station items.! !!GdsStructure methodsFor: 'example' stamp: 'kf 10/27/2009 10:31'!fillExampleInstance	self currentItem boundary.	self currentItem layerNumber: 1.	self currentItem ce: 0@0.	self currentItem ce: 0@100.	self currentItem ce: 0@100.	self currentItem ce: 0@100.	self currentItem ce: 0@100.	self currentItem ce: 100@100.	self currentItem ce: 100@0.	self currentItem put.	self currentItem path.	self currentItem layerNumber: 3.	self currentItem ce: 0@0.	self currentItem ce: 0@100.	self currentItem ce: 100@100.	self currentItem ce: 100@0.	self currentItem translate: 20@30.	self currentItem put.! !!GdsStructure methodsFor: 'initialization' stamp: 'kf 10/22/2009 16:18'!database: aGdsDatabase.	database := aGdsDatabase.	! !!GdsStructure methodsFor: 'initialization' stamp: 'kf 10/27/2009 15:19'!initialize	| time |	super initialize.		time := DateAndTime now.	timeCreated := time copy.	timeModified := time copy.	colElements := OrderedCollection new.	maxKeyNumber := nil.	layers := GdsLayers new.	! !!GdsStructure methodsFor: 'initialization' stamp: 'kf 10/31/2009 21:01'!release	timeCreated := nil.	timeModified := nil.	colElements ifNotNil: [ colElements do: [:each | each release]].	colElements := nil.	maxKeyNumber := nil.	layers release.	layers := nil.	name := nil.	super release.	! !!GdsStructure methodsFor: 'initialization' stamp: 'kf 10/21/2009 20:38'!setName: aStructureName 	name := GdsCompatibility default coerceStructureName:  aStructureName.	! !!GdsStructure methodsFor: 'initialization' stamp: 'kf 10/21/2009 20:38'!setName: aStructureName database: aGdsDatabase.	self setName: aStructureName.	database := aGdsDatabase.	! !!GdsStructure methodsFor: 'key generator' stamp: 'kf 11/12/2008 09:22'!lookupMaxKeyNumber	| filledElements | 	filledElements := self elements select: [:each | each keyNumberFilled].	filledElements 		ifEmpty: [^0]		ifNotEmpty: [^(filledElements collect: [:each | each keyNumber]) max].! !!GdsStructure methodsFor: 'key generator' stamp: 'kf 11/12/2008 09:16'!maxKeyNumber	maxKeyNumber ifNil: [maxKeyNumber := self lookupMaxKeyNumber].	^maxKeyNumber		! !!GdsStructure methodsFor: 'key generator' stamp: 'kf 11/12/2008 09:18'!nextKeyNumber	| newValue |	newValue := self maxKeyNumber + 1.	maxKeyNumber := newValue.	^newValue	! !!GdsStructure methodsFor: 'attribute' stamp: 'kf 9/19/2008 18:39'!name	^name.! !!GdsStructure methodsFor: 'attribute' stamp: 'kf 6/15/2009 15:29'!nameWithExtension	^self name, self newExtension ! !!GdsStructure methodsFor: 'attribute' stamp: 'kf 6/15/2009 15:27'!newExtension	^'.', self newExtensionBody! !!GdsStructure methodsFor: 'attribute' stamp: 'kf 6/15/2009 16:42'!newExtensionBody	^'structure'! !!GdsStructure methodsFor: 'attribute' stamp: 'kf 10/23/2008 16:53'!timeCreated	timeCreated ifNil: [timeCreated := DateAndTime now].	^timeCreated.! !!GdsStructure methodsFor: 'attribute' stamp: 'kf 10/23/2008 16:54'!timeModified	timeModified ifNil: [timeModified := DateAndTime now].	^timeModified.! !!GdsStructure methodsFor: '*GdsFeel-Morphic-Extension' stamp: 'kf 11/4/2009 21:54'!fileDirectoryForPreview	| libFd folderName |	libFd := database fileDirectoryForThumbnails .	folderName := self nameWithExtension.	(libFd directoryExists: folderName)		ifFalse: [libFd createDirectory: folderName].	^FileDirectory on: (libFd fullPathFor: folderName).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsStructure class	instanceVariableNames: ''!!GdsStructure class methodsFor: 'as yet unclassified' stamp: 'kf 11/12/2008 09:12'!keyNumberForInStructure	^1! !!GdsStructure class methodsFor: 'as yet unclassified' stamp: 'kf 9/19/2008 18:23'!named: aStructureName	! !!GdsStructure class methodsFor: 'as yet unclassified' stamp: 'kf 11/12/2008 09:31'!safeNoElementDataExtent	^(-100@-100) corner: (100@100)! !GdsLibrary subclass: #GdsTransientBetaLibrary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Container'!!GdsTransientBetaLibrary methodsFor: 'as yet unclassified' stamp: 'kf 6/16/2009 22:51'!elementClass	^GdsTransientBetaStructure	! !!GdsTransientBetaLibrary methodsFor: 'as yet unclassified' stamp: 'kf 6/17/2009 22:39'!fileDirectoryForWork	^self class fileDirectoryForBeta! !!GdsTransientBetaLibrary methodsFor: 'as yet unclassified' stamp: 'kf 6/16/2009 22:48'!isTransient	^ true! !!GdsTransientBetaLibrary methodsFor: 'as yet unclassified' stamp: 'kf 6/22/2009 15:46'!libName	^'BETA'! !!GdsTransientBetaLibrary methodsFor: 'as yet unclassified' stamp: 'kf 6/17/2009 15:19'!name: aLibName databaseUnit: aInteger unitString: aUnitString	self privateName: aLibName databaseUnit:  aInteger unitString: aUnitString.! !!GdsTransientBetaLibrary methodsFor: 'maintenance' stamp: 'kf 6/17/2009 15:30'!closeWithUpdate	self name: 'BETA' databaseUnit: 1000 unitString: 'MICRON'.		self structures do: [:each | each fileOutAsXmlNew ].	super close.	self deleteFileDirectoryBlock: [self fileDirectoryForEdit].! !!GdsTransientBetaLibrary methodsFor: 'objects from disk' stamp: 'kf 6/17/2009 22:39'!loadStructures	| fd |	fd := self class fileDirectoryForBeta.	fd assureExistence.	self loadStructures: fd! !!GdsTransientBetaLibrary methodsFor: 'objects from disk' stamp: 'kf 6/16/2009 22:46'!loadStructures: aFileDirectory 	| names |	names := aFileDirectory fileNamesMatching: '*.gdsfeelbeta'.	names := names 				select: [:name | GdsCompatibility default isValidStructureName: (FileDirectory baseNameFor: name)].	names do: 			[:each | 			| name structure |			name := FileDirectory baseNameFor: each.			structure := self newStructureNamed: name.			[structure loadBetaFromPath: (aFileDirectory fullPathFor: each)] on: Error				do: 					[:ex | 					Transcript						cr;						show: (String streamContents: 										[:s | 										s nextPutAll: '***ERROR***'.										s nextPutAll: ' '.										s nextPutAll: 'skip broken structure: '.										s nextPutAll: name]).					self removeStructure: structure]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsTransientBetaLibrary class	instanceVariableNames: ''!!GdsTransientBetaLibrary class methodsFor: 'as yet unclassified' stamp: 'kf 6/17/2009 22:38'!fileDirectoryForBeta	^FileDirectory on: (GdsFeel pathToBeta).	! !!GdsTransientBetaLibrary class methodsFor: 'as yet unclassified' stamp: 'kf 6/17/2009 22:42'!hasBetaFolder	^self fileDirectoryForBeta exists.	! !GdsStructure subclass: #GdsTransientBetaStructure	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Container'!!GdsTransientBetaStructure methodsFor: 'printing' stamp: 'kf 6/16/2009 23:20'!betaFilename	^self name , '.gdsfeelbeta'.! !!GdsTransientBetaStructure methodsFor: 'objects from disk' stamp: 'kf 6/17/2009 22:39'!fileDirectoryForLoad	^database class fileDirectoryForBeta ! !!GdsTransientBetaStructure methodsFor: 'objects from disk' stamp: 'kf 6/17/2009 22:37'!fileOutAsXml	self 		fileOutAsXmlInto: (self fileDirectoryForBeta)		localName: self betaFilename.! !!GdsTransientBetaStructure methodsFor: 'objects from disk' stamp: 'kf 6/17/2009 15:15'!saveWithUpdate	self saveBlock: [super fileOutAsXmlNew].! !