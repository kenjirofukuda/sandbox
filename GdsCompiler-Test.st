TestCase subclass: #GdsTestCase	instanceVariableNames: 'evaluter model'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsTestCase methodsFor: 'running' stamp: 'kf 5/25/2009 21:30'!setUp	super setUp.	evaluter := GplEvaluter new.	! !!GdsTestCase methodsFor: 'running' stamp: 'kf 5/29/2009 11:56'!tearDown	evaluter := nil.	model := nil.	! !GdsTestCase subclass: #GdsBooleanTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsBooleanTest methodsFor: 'test' stamp: 'kf 5/23/2009 14:49'!testAcceptableExpression	| input result expResult |	input := '1'.	expResult := true.	result := GdsBoolean acceptableExpression: input.	self assert: result = expResult.	input := '0'.	expResult := true.	result := GdsBoolean acceptableExpression: input.	self assert: result = expResult.		input := 'TRUE'.	expResult := true.	result := GdsBoolean acceptableExpression: input.	self assert: result = expResult.	input := 'FALSE'.	expResult := true.	result := GdsBoolean acceptableExpression: input.	self assert: result = expResult.		input := '1.0'.	expResult := false.	result := GdsBoolean acceptableExpression: input.	self assert: result = expResult.			input := '0.0'.	expResult := false.	result := GdsBoolean acceptableExpression: input.	self assert: result = expResult.		input := 'false'. "disallow lowercase"	expResult := false.	result := GdsBoolean acceptableExpression: input.	self assert: result = expResult.		input := '1E-17'. "disallow floating point"	expResult := false.	result := GdsBoolean acceptableExpression: input.	self assert: result = expResult.	! !!GdsBooleanTest methodsFor: 'test' stamp: 'kf 5/27/2009 16:04'!testFromLiteral	self assert: [(GdsBoolean fromLiteral: 'TRUE') asSmalltalkValue = 1].	self assert: [(GdsBoolean fromLiteral: 'FALSE') asSmalltalkValue = 0].	self assert: [(GdsBoolean fromLiteral: '1') asSmalltalkValue = 1].			self assert: [(GdsBoolean fromLiteral: '0') asSmalltalkValue = 0].		"only use 0 1 TRUE FALSE"	self should: [(GdsBoolean fromLiteral: '2')] raise: GplSyntaxError.		self should: [(GdsBoolean fromLiteral: '0000000001')] raise: GplSyntaxError.		"cant ue real"	self should: [(GdsBoolean fromLiteral: '1.0')] raise: GplSyntaxError.		self should: [(GdsBoolean fromLiteral: '0.0')] raise: GplSyntaxError.		"currently spec. only UPPECALSE"	self should: [(GdsBoolean fromLiteral: 'true')] raise: GplSyntaxError.		self should: [(GdsBoolean fromLiteral: 'false')] raise: GplSyntaxError.		self should: [(GdsBoolean fromLiteral: 'True')] raise: GplSyntaxError.		self should: [(GdsBoolean fromLiteral: 'False')] raise: GplSyntaxError.		"currently spec. both side space is error"	self should: [(GdsBoolean fromLiteral: ' 1')] raise: GplSyntaxError.		self should: [(GdsBoolean fromLiteral: '1 ')] raise: GplSyntaxError.		self should: [(GdsBoolean fromLiteral: ' 1 ')] raise: GplSyntaxError.						! !!GdsBooleanTest methodsFor: 'test' stamp: 'kf 6/11/2009 20:49'!testIsList				self deny: [(GdsBoolean fromLiteral: 'TRUE') isList].	! !!GdsBooleanTest methodsFor: 'test' stamp: 'kf 5/27/2009 14:11'!testLength	self assert: [(true asGdsValue) length = 1].		self assert: [(false asGdsValue) length = 1].				! !!GdsBooleanTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:21'!testMode			self assert: [(GdsBoolean fromLiteral: 'TRUE') mode = 1].	self assert: [(GdsBoolean fromLiteral: 'FALSE') mode = 1].	! !!GdsBooleanTest methodsFor: 'test' stamp: 'kf 4/28/2009 01:12'!testRank				self assert: [(GdsBoolean fromLiteral: 'TRUE') rank = 0].	! !!GdsBooleanTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:19'!testShape				self assert: [(GdsBoolean fromLiteral: 'TRUE') shape = #()].	! !!GdsBooleanTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:19'!testSize				self assert: [(GdsBoolean fromLiteral: 'TRUE') size = 1].	! !!GdsBooleanTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:20'!testTypeString				self assert: [(GdsBoolean fromLiteral: 'TRUE') typeString = 'LOGICAL'].	self assert: [(GdsBoolean fromLiteral: 'FALSE') typeString = 'LOGICAL'].	! !GdsTestCase subclass: #GdsIntegerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsIntegerTest methodsFor: 'test' stamp: 'kf 5/24/2009 22:34'!testAcceptableExpression	| input result expResult |	input := '1'.	expResult := true.	result := GdsInteger acceptableExpression: input.	self assert: result = expResult.		input := '1.0'.	expResult := false.	result := GdsInteger acceptableExpression: input.	self assert: result = expResult.		input := '+1'.	expResult := true.	result := GdsInteger acceptableExpression: input.	self deny: result = expResult description: 'can''t use + sign'.		input := '32767'.	expResult := true.	result := GdsInteger acceptableExpression: input.	self assert: result = expResult.		input := '32768'. "overflow "	expResult := false.	result := GdsInteger acceptableExpression: input.	self assert: result = expResult.		input := '-32768'. " "	expResult := true.	result := GdsInteger acceptableExpression: input.	self assert: result = expResult.		input := '-32769'. " "	expResult := false.	result := GdsInteger acceptableExpression: input.	self assert: result = expResult.		input := '1E-17'. "disallow floating point"	expResult := false.	result := GdsInteger acceptableExpression: input.	self assert: result = expResult.	! !!GdsIntegerTest methodsFor: 'test' stamp: 'kf 5/27/2009 16:04'!testFromLiteral	self assert: [(GdsInteger fromLiteral: '1') asSmalltalkValue = 1].			self assert: [(GdsInteger fromLiteral: '0') asSmalltalkValue = 0].		self assert: [(GdsInteger fromLiteral: '0000000001') asSmalltalkValue = 1].		self assert: [(GdsInteger fromLiteral: '-32768') asSmalltalkValue = -32768].	"cant use + sign"			self should:  [(GdsInteger fromLiteral: '+32767')] raise: GplSyntaxError.			self should:  [(GdsInteger fromLiteral: '1.0')] raise: GplSyntaxError.			"currently spec. both side space is error"	self should: [(GdsInteger fromLiteral: ' 1')] raise: GplSyntaxError.		self should: [(GdsInteger fromLiteral: '1 ')] raise: GplSyntaxError.		self should: [(GdsInteger fromLiteral: ' 1 ')] raise: GplSyntaxError.						! !!GdsIntegerTest methodsFor: 'test' stamp: 'kf 6/11/2009 20:49'!testIsList				self deny: [(GdsInteger fromLiteral: '1') isList].	! !!GdsIntegerTest methodsFor: 'test' stamp: 'kf 5/25/2009 00:10'!testMode			self assert: [(GdsInteger fromLiteral: '1') mode = 2].! !!GdsIntegerTest methodsFor: 'test' stamp: 'kf 4/28/2009 01:12'!testRank				self assert: [(GdsInteger fromLiteral: '1') rank = 0].	! !!GdsIntegerTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:15'!testShape				self assert: [(GdsInteger fromLiteral: '1') shape = #()].	! !!GdsIntegerTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:16'!testSize				self assert: [(GdsInteger fromLiteral: '1') size = 1].	! !!GdsIntegerTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:15'!testTypeString				self assert: [(GdsInteger fromLiteral: '1') typeString = 'INTEGER'].	! !GdsTestCase subclass: #GdsListTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsListTest methodsFor: 'private' stamp: 'kf 5/25/2009 21:34'!sampleList	^evaluter evaluteLine: '"ABC" ; IOTA 3 ; 3 4 RESHAPE IOTA 12'.! !!GdsListTest methodsFor: 'tests' stamp: 'kf 5/29/2009 17:14'!testAtSubscript	evaluter evaluteLine: 'L := "ABC"; IOTA 3'.	self should: [evaluter evaluteLine: 'L[0]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'L[3]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'L[]' ] raise: GplRuntimeError.	self shouldnt: [evaluter evaluteLine: 'L[1.0]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'L[1.1]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'L[2;2]' ] raise: GplRuntimeError.	self shouldnt: [evaluter evaluteLine: 'L[1]' ] raise: GplRuntimeError.	self shouldnt: [evaluter evaluteLine: 'L[2]' ] raise: GplRuntimeError.	! !!GdsListTest methodsFor: 'tests' stamp: 'kf 6/11/2009 20:48'!testIsList				self assert: [self sampleList isList].		! !!GdsListTest methodsFor: 'tests' stamp: 'kf 5/25/2009 20:54'!testLength	self assert: [self sampleList length = 3]	! !!GdsListTest methodsFor: 'tests' stamp: 'kf 5/25/2009 20:49'!testMode	self assert: [self sampleList mode = 6] 	! !!GdsListTest methodsFor: 'tests' stamp: 'kf 5/27/2009 16:40'!testShape	self should: [self sampleList shape] raise: GplError	! !!GdsListTest methodsFor: 'tests' stamp: 'kf 5/27/2009 15:25'!testSize	self should: [self sampleList size] raise: GplError	! !!GdsListTest methodsFor: 'tests' stamp: 'kf 5/25/2009 20:50'!testTypeString	self assert: [self sampleList typeString = 'LIST'] 	! !GdsTestCase subclass: #GdsMatrixTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsMatrixTest methodsFor: 'private' stamp: 'kf 5/25/2009 21:34'!sampleMatrix	^evaluter evaluteLine: '3 4 RESHAPE IOTA 12'.! !!GdsMatrixTest methodsFor: 'tests' stamp: 'kf 6/11/2009 20:49'!testIsList				self deny: [self sampleMatrix isList].	! !!GdsMatrixTest methodsFor: 'tests' stamp: 'kf 5/25/2009 21:05'!testLength	self assert: [self sampleMatrix length = 1].! !!GdsMatrixTest methodsFor: 'tests' stamp: 'kf 5/25/2009 21:05'!testMode	self assert: [self sampleMatrix mode = 2].! !!GdsMatrixTest methodsFor: 'tests' stamp: 'kf 5/25/2009 21:05'!testShape	self assert: [self sampleMatrix shape = #(3 4)].! !!GdsMatrixTest methodsFor: 'tests' stamp: 'kf 6/7/2009 18:03'!testSize	self assert: [self sampleMatrix size = 12].	evaluter evaluteLine: 'M := 3 4 RESHAPE IOTA 12'.	"SIZE INVARIANT using MONADIC operators"	self assert: [(evaluter evaluteLine: 'SIZE M') asSmalltalkValue  = 12].	self assert: [(evaluter evaluteLine: 'SIZE -M') asSmalltalkValue  = 12].		self assert: [(evaluter evaluteLine: 'SIZE +M') asSmalltalkValue  = 12].			self assert: [(evaluter evaluteLine: 'SIZE *M') asSmalltalkValue  = 12].				self assert: [(evaluter evaluteLine: 'SIZE %M') asSmalltalkValue  = 12].								! !!GdsMatrixTest methodsFor: 'tests' stamp: 'kf 5/25/2009 21:07'!testTypeString	self deny: [self sampleMatrix typeString = 'MATRIX'].	self assert: [self sampleMatrix typeString = 'INTEGER'].! !GdsTestCase subclass: #GdsNullTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsNullTest methodsFor: 'test' stamp: 'kf 5/24/2009 22:42'!testAcceptableExpression	| input result expResult |	input := '""'.	expResult := true.	result := GdsNull acceptableExpression: input.	self assert: result = expResult.		input := 'NULL'. "not represents NULL"	expResult := false.	result := GdsNull acceptableExpression: input.	self assert: result = expResult.		input := ''''''. "not single qute"	expResult := false.	result := GdsNull acceptableExpression: input.	self assert: result = expResult.	input := '" "'. "not inside space"	expResult := false.	result := GdsNull acceptableExpression: input.	self assert: result = expResult.! !!GdsNullTest methodsFor: 'test' stamp: 'kf 5/27/2009 16:56'!testAtSubscript	self should: [GdsNull instance atSubscript: (1 asGdsValue)] raise: GplRuntimeError.	self should: [GdsNull instance atSubscript: (#(1 2) asGdsValue)] raise: GplRuntimeError.	self should: [evaluter evaluteLine: '""[1]' ] raise: GplRuntimeError.! !!GdsNullTest methodsFor: 'test' stamp: 'kf 5/27/2009 16:13'!testFromLiteral	self 		should: [ GdsNull fromLiteral: '0' ]		raise: GplSyntaxError .	self 		should: [ GdsNull fromLiteral: 'NULL' ]		raise: GplSyntaxError.	self 		should: [ GdsNull fromLiteral: 'nil' ]		raise: GplSyntaxError.	self 		should: [ GdsReal fromLiteral: '" "' ]		raise: GplSyntaxError.	self 		should: [ GdsReal fromLiteral: '"' ]		raise: GplSyntaxError.	self 		should: [ GdsReal fromLiteral: '''''' ]		raise: GplSyntaxError.	self 		should: [ GdsReal fromLiteral: $" ]		raise: GplSyntaxError.	self 		should: [ GdsReal fromLiteral: $' ]		raise: GplSyntaxError.	self assert: [ (GdsNull fromLiteral: '""') == GdsNull instance ]! !!GdsNullTest methodsFor: 'test' stamp: 'kf 6/11/2009 20:50'!testIsList				self deny: [GdsNull instance isList].	! !!GdsNullTest methodsFor: 'test' stamp: 'kf 5/24/2009 22:43'!testMode				self assert: [(GdsNull instance) mode = 5].	! !!GdsNullTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:18'!testRank				self assert: [GdsNull instance rank = 1].		! !!GdsNullTest methodsFor: 'test' stamp: 'kf 5/19/2009 13:59'!testShape				self assert: [GdsNull instance shape = #()].		! !!GdsNullTest methodsFor: 'test' stamp: 'kf 5/25/2009 20:59'!testSize				| result expResult |	self assert: [GdsNull instance size = 0].			expResult := 0.		result := (GdsString fromLiteral: '""') size.	self assert: result = expResult.	! !!GdsNullTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:18'!testTypeString				self assert: [(GdsNull instance) typeString = 'NULL'].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsNullTest class	instanceVariableNames: ''!GdsTestCase subclass: #GdsRealTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsRealTest methodsFor: 'test' stamp: 'kf 5/24/2009 22:23'!testAcceptableExpression	| input result expResult |	input := '1'.	expResult := true.	result := GdsReal acceptableExpression: input.	self assert: result = expResult.		input := '-1'.	expResult := true.	result := GdsReal acceptableExpression: input.	self assert: result = expResult.		input := '+1'.	expResult := false. "cant use +sign "	result := GdsReal acceptableExpression: input.	self assert: result = expResult.		input := '1.0'.	expResult := true.	result := GdsReal acceptableExpression: input.	self assert: result = expResult.		input := '1E-17'.	expResult := true.	result := GdsReal acceptableExpression: input.	self assert: result = expResult.		input := '1E+17'.	expResult := true.	result := GdsReal acceptableExpression: input.	self deny: [result = expResult] description: 'can''t use exponensial + sign'.		input := '-1.0E+17'.	expResult := true.	result := GdsReal acceptableExpression: input.	self deny: result = expResult.		input := '-1.0e+17'. "disallow lowercase e on GPL"	expResult := false.	result := GdsReal acceptableExpression: input.	self assert: result = expResult.	! !!GdsRealTest methodsFor: 'test' stamp: 'kf 5/27/2009 16:05'!testFromLiteral	self assert: [(GdsReal fromLiteral: '1') asSmalltalkValue isKindOf: Float].			self should:  [(GdsReal fromLiteral: 'TRUE')] raise: GplSyntaxError.					self should:  [(GdsReal fromLiteral: '+1.0')] raise: GplSyntaxError.			self shouldnt:  [(GdsReal fromLiteral: '-1.0')] raise: GplSyntaxError.			self shouldnt:  [(GdsReal fromLiteral: '1E16')] raise: GplSyntaxError.			self should:  [(GdsReal fromLiteral: '1E+16')] raise: GplSyntaxError.			self should:  [(GdsReal fromLiteral: '1e-16')] raise: GplSyntaxError.			self assert: [(GdsReal fromLiteral: '1.000000') gplString = '1.'].			self assert: [(GdsReal fromLiteral: '0.000000') gplString = '0.'].			self assert: [(GdsReal fromLiteral: '0.1234') gplString = '.1234'].							! !!GdsRealTest methodsFor: 'test' stamp: 'kf 6/11/2009 20:51'!testIsList				self deny: [(GdsReal fromLiteral: '1.0') isList].		! !!GdsRealTest methodsFor: 'test' stamp: 'kf 5/27/2009 14:12'!testLength	self assert: [(1.0 asGdsValue) length = 1].	! !!GdsRealTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:08'!testMode				self assert: [(GdsReal fromLiteral: '1.0') mode = 3].		! !!GdsRealTest methodsFor: 'test' stamp: 'kf 4/28/2009 01:13'!testRank				self assert: [(GdsReal fromLiteral: '1.0') rank = 0].		self assert: [(GdsReal fromLiteral: '1.0') rank = (GdsReal fromLiteral: '1E-16') rank].		! !!GdsRealTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:10'!testShape				self assert: [(GdsReal fromLiteral: '1.0') shape = #()].		! !!GdsRealTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:17'!testSize				self assert: [(GdsReal fromLiteral: '1.0') size = 1].		! !!GdsRealTest methodsFor: 'test' stamp: 'kf 5/19/2009 14:14'!testTypeString				self assert: [(GdsReal fromLiteral: '1.0') typeString = 'REAL'].		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsRealTest class	instanceVariableNames: ''!GdsTestCase subclass: #GdsScalarTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsScalarTest methodsFor: 'tests' stamp: 'kf 9/9/2012 09:05'!testApplySymbolTo	| expResult result |		"not a GdsDataStructure"	self should: [(1 asGdsValue applySymbol: #+ to: 1) ] raise: Exception.	"not a GdsDataStructure"	self should: [(1 asGdsValue applySymbol: #+ to: GdsNull instance) ] raise: Exception.		"{scalar} {scalar}"	expResult := 2.0.	result := (1 asGdsValue applySymbol: #+ to: (1 asGdsValue)) asSmalltalkValue.	self assert: [result = expResult].		"{scalar} {vector}"	expResult := #(2.0 3.0).	result := (1 asGdsValue applySymbol: #+ to: (#(1 2) asGdsValue)) asSmalltalkValue.	self assert: [result = expResult].	"{scalar} {scalar}"	expResult := 0.0.	result := (1 asGdsValue applySymbol: #- to: (1 asGdsValue)) asSmalltalkValue.	self assert: [result = expResult].		"{scalar} {vector}"	expResult := #(0.0 -1.0).	result := (1 asGdsValue applySymbol: #- to: (#(1 2) asGdsValue)) asSmalltalkValue.	self assert: [result = expResult].	"{scalar} {scalar}"	expResult := 1.0.	result := (1 asGdsValue applySymbol: #* to: (1 asGdsValue)) asSmalltalkValue.	self assert: [result = expResult].		"{scalar} {vector}"	"? 2 * 1 2"	"2. 4."	expResult := #(2.0 4.0).	result := (2 asGdsValue applySymbol: #* to: (#(1 2) asGdsValue)) asSmalltalkValue.	self assert: [result = expResult].	"{scalar} {scalar}"	"? 1 % 1"	"1."	expResult := 1.0.	result := (1 asGdsValue applySymbol: #% to: (1 asGdsValue)) asSmalltalkValue.	self assert: [result = expResult].		"{scalar} {vector}"	"? 1 % 1 2"	"1.0 0.5"	expResult := #(1.0 0.5).	result := (1 asGdsValue applySymbol: #% to: (#(1 2) asGdsValue)) asSmalltalkValue.	self assert: [result = expResult].	"other alithmetic operator"	self should: [(1 asGdsValue applySymbol: #/ to: (1 asGdsValue)) ] raise: Exception.	self should: [(1 asGdsValue applySymbol: #// to: (1 asGdsValue)) ] raise: Exception.	self should: [(1 asGdsValue applySymbol: #\\ to: (1 asGdsValue)) ] raise: Exception.	! !!GdsScalarTest methodsFor: 'tests' stamp: 'kf 5/27/2009 16:35'!testAtSubscript	self should: [1 asGdsValue atSubscript: (1 asGdsValue)] raise: GplRuntimeError.	self should: [1.0 asGdsValue atSubscript: (#(1 2) asGdsValue)] raise: GplRuntimeError.	self should: [$a asGdsValue atSubscript: (GdsNull instance)] raise: GplRuntimeError.		evaluter evaluteLine: 'S := 1'.		self should: [evaluter evaluteLine: 'S[1]'] raise: GplRuntimeError.! !!GdsScalarTest methodsFor: 'tests' stamp: 'kf 6/11/2009 20:51'!testIsList				self deny: [(1.0 asGdsValue)  isList].! !!GdsScalarTest methodsFor: 'tests' stamp: 'kf 5/27/2009 14:08'!testLength	self assert: [(1 asGdsValue) length = 1].	self assert: [(1.0 asGdsValue) length = 1].		self assert: [(true asGdsValue) length = 1].		self assert: [(false asGdsValue) length = 1].			self assert: [($a asGdsValue) length = 1].				! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsScalarTest class	instanceVariableNames: ''!GdsTestCase subclass: #GdsStringTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsStringTest methodsFor: 'tests' stamp: 'kf 5/24/2009 22:47'!testAcceptableExpression	self deny:  (GdsString acceptableExpression: '').	self deny:  (GdsString acceptableExpression: '"').	self deny:  (GdsString acceptableExpression: $' asString).			self assert:  (GdsString acceptableExpression: '""').				! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 5/27/2009 15:26'!testApplySymbolTo	| sample |	sample := 'ABC' asGdsValue.	"not a GdsDataStructure"	self should: [(sample applySymbol: #+ to: 1) ] raise: GplError.		"self + self"	self should: [(sample applySymbol: #+ to: sample) ] raise: GplError.		"self -  self"	self should: [(sample applySymbol: #- to: sample) ] raise: GplError.		"self *  self"	self should: [(sample applySymbol: #* to: sample) ] raise: GplError.		"self %  self"	self should: [(sample applySymbol: #% to: sample) ] raise: GplError.! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 9/15/2012 17:36'!testFromEmbedLiteral	| |		"not close >"	self should: [(GdsString fromLiteral: '"Calma<CR GDSII"') ] raise: GplSyntaxError.		"not open <"	self should: [(GdsString fromLiteral: '"Calma CR> GDSII"') ] raise: GplSyntaxError.		"nested <"	self should: [(GdsString fromLiteral: '"Calma<<CR> GDSII"') ] raise: GplSyntaxError.		"nested >"	self should: [(GdsString fromLiteral: '"Calma<CR>> GDSII"') ] raise: GplSyntaxError.	"nested <<>>"	self should: [(GdsString fromLiteral: '"Calma<<CR>> GDSII"') ] raise: GplSyntaxError.	"ok"	self shouldnt: [(GdsString fromLiteral: '"Calma<CR> GDSII"') ] raise: GplSyntaxError.	! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 9/15/2012 19:40'!testFromLiteral	| result expResult |	expResult := GdsNull instance.		result := GdsString fromLiteral: '""'.	self assert: result = expResult.		self shouldnt: [(GdsString fromLiteral: '"ABC"') ] raise: GplSyntaxError.	"double quote only."	self should: [(GdsString fromLiteral: '"') ] raise: GplSyntaxError.	"missing closing quote"	self should: [(GdsString fromLiteral: '"ABC') ] raise: GplSyntaxError.	"single quote not support"	self should: [(GdsString fromLiteral: '''ABC''') ] raise: GplSyntaxError.		! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 9/15/2012 19:46'!testFromLiteralExtension	| result expResult msg |	msg :=  'TODO: implement < > notation in string context'.		expResult := String with: (Character value: 0)  .	result := (GdsString fromLiteral: '"<NUL>"') gplString.	self assert: result = expResult description: msg.		expResult := (Character value: 8r7) asString .	result := (GdsString fromLiteral: '"<BEL>"') gplString.	self assert: result = expResult description: msg.	expResult := String tab .	result := (GdsString fromLiteral: '"<TAB>"') gplString.	self assert: result = expResult description: msg.	expResult := String lf .	result := (GdsString fromLiteral: '"<LF>"') gplString.	self assert: result = expResult description: msg.	expResult := (Character value: 8r14) asString .	result := (GdsString fromLiteral: '"<FF>"') gplString.	self assert: result = expResult description: msg.		expResult := String cr .	result := (GdsString fromLiteral: '"<CR>"') gplString.	self assert: result = expResult description: msg.	expResult := (Character value: 8r15) asString .	result := (GdsString fromLiteral: '"<NL>"') gplString.	self assert: result = expResult description: msg.	expResult := (Character value: 8r33) asString .	result := (GdsString fromLiteral: '"<ESC>"') gplString.	self assert: result = expResult description: msg.	expResult := (Character value: 8r36) asString .	result := (GdsString fromLiteral: '"<BROFF>"') gplString.	self assert: result = expResult description: msg.	expResult := (Character value: 8r37) asString .	result := (GdsString fromLiteral: '"<BRON>"') gplString.	self assert: result = expResult description: msg.	expResult := (Character value: 8r42) asString .	result := (GdsString fromLiteral: '"<QT>"') gplString.	self assert: result = expResult description: msg.	expResult := '<' .	result := (GdsString fromLiteral: '"<74>"') gplString.	self assert: result = expResult description: msg.	expResult := '>' .	result := (GdsString fromLiteral: '"<76>"') gplString.	self assert: result = expResult description: msg.	expResult := (Character value: 8r177) asString .	result := (GdsString fromLiteral: '"<DEL>"') gplString.	self assert: result = expResult description: msg.! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 9/15/2012 19:49'!testFromLiteralExtension2	| result expResult msg |	msg :=  'TODO: implement < > notation in string context'.		expResult := '"ABC"'.	result := (GdsString fromLiteral: '"<QT>ABC<QT>"') gplString.	self assert: result = expResult description: msg.		expResult := 'ABCDEF'.	result := (GdsString fromLiteral: '"ABC<CR>DEF"') gplString.	self assert: result = expResult description: msg.		expResult := '<CR>'.	result := (GdsString fromLiteral: '"<74>CR<76>"') gplString.	self assert: result = expResult description: msg.	expResult := 'Gerald Lott'.	result := (GdsString fromLiteral: '"<107><145><162><141><154><144><40><114><157><164><164>"') gplString.	self assert: result = expResult description: msg.! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 6/11/2009 20:52'!testIsList	self deny: [(GdsString fromLiteral: '"ABC"') isList].	! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 9/15/2012 19:42'!testLength	"length is a list element size not a vector size"	self assert: [(GdsString fromLiteral: '"A"') length = 1].	self assert: [(GdsString fromLiteral: '"AB"') length = 1].	self assert: [(GdsString fromLiteral: '"ABC"') length = 1].			! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 5/19/2009 14:05'!testMode	| result expResult |	expResult := 4.		result := (GdsString fromLiteral: '"ABC"') mode.	self assert: result = expResult.	! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 5/19/2009 13:49'!testRank	| result expResult |	expResult := 1.		result := (GdsString fromLiteral: '"ABC"') rank.	self assert: result = expResult.	! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 5/19/2009 13:54'!testShape	| result expResult |	expResult := 3.		result := (GdsString fromLiteral: '"ABC"') shape.	self assert: result = expResult.	! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 5/25/2009 20:58'!testSize	| result expResult |	expResult := 1.		result := (GdsString fromLiteral: '"A"') size.	self assert: result = expResult.		expResult := 2.		result := (GdsString fromLiteral: '"AB"') size.	self assert: result = expResult.		expResult := 3.		result := (GdsString fromLiteral: '"ABC"') size.	self assert: result = expResult.	! !!GdsStringTest methodsFor: 'tests' stamp: 'kf 5/20/2009 00:30'!testTypeString	| result expResult |	expResult := 'CHAR'.		result := (GdsString fromLiteral: '"ABC"') typeString.	self assert: result = expResult.		expResult := 'NULL'.		result := (GdsString fromLiteral: '""') typeString.	self assert: result = expResult.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsStringTest class	instanceVariableNames: ''!GdsTestCase subclass: #GdsVectorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GdsVectorTest methodsFor: 'tests' stamp: 'kf 5/27/2009 15:27'!testApplySymbolTo	| expResult result |		"{vector} {scalr}"	expResult := #(2.0 3.0 4.0).	result := ((#(1 2 3) asGdsValue)  applySymbol: #+ to: (1 asGdsValue) ) asSmalltalkValue.	self assert: [result = expResult].	"{vector} {vector}"	expResult := #(5.0 7.0 9.0).	result := ((#(1 2 3) asGdsValue)  applySymbol: #+ to: (#(4 5 6) asGdsValue) ) asSmalltalkValue.	self assert: [result = expResult].	"{vector} {scalr}"	expResult := #(0.0 1.0 2.0).	result := ((#(1 2 3) asGdsValue)  applySymbol: #- to: (1 asGdsValue) ) asSmalltalkValue.	self assert: [result = expResult].	"{vector} {vector}"	expResult := #(-3.0 -3.0 -3.0).	result := ((#(1 2 3) asGdsValue)  applySymbol: #- to: (#(4 5 6) asGdsValue) ) asSmalltalkValue.	self assert: [result = expResult].	"{illigal data}"	self should: [(#(1 2 3) asGdsValue)  applySymbol: #- to: GdsNull instance ] raise: GplError.	"{illigal data}"	self should: [(#(1 2 3) asGdsValue)  applySymbol: #- to: (GdsString fromLiteral: '"ABC"') ] raise: GplError.		"{illigal size}"	self should: [(#(1 2 3) asGdsValue)  applySymbol: #- to: (#(4 5 6 7) asGdsValue) ] raise: GplError! !!GdsVectorTest methodsFor: 'tests' stamp: 'kf 5/29/2009 17:14'!testAtSubscript	self assert: [((GdsVector fromLiteral: '1 2 3') atSubscript: (1 asGdsValue)) asSmalltalkValue = 1] .	self shouldnt: [evaluter evaluteLine: '(1 2 3)[1]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: '(1 2 3)[]' ] raise: GplRuntimeError.	self shouldnt: [evaluter evaluteLine: '(1 2 3)[1.0]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: '(1 2 3)[""]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: '(1 2 3)[0]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: '(1 2 3)[4]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: '(1 2 3)[-1]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: '(1 2 3)[1;]' ] raise: GplRuntimeError.	self should: [evaluter evaluteLine: '(1 2 3)[;1]' ] raise: GplRuntimeError.	evaluter evaluteLine: 'V := IOTA 3'.		"out of range"		self should: [evaluter evaluteLine: 'V[0]'] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'V[4]'] raise: GplRuntimeError.	"empty sabscript"	self should: [evaluter evaluteLine: 'V[]'] raise: GplRuntimeError.	"illigal data mode"	self should: [evaluter evaluteLine: 'V[""]'] raise: GplRuntimeError.	self shouldnt: [evaluter evaluteLine: 'V[1.0]'] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'V[1.1]'] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'V["ABC"]'] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'V["1 2 3"]'] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'V[2 1 RESHAPE 1]'] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'V[1 2 RESHAPE 1]'] raise: GplRuntimeError.	"list access"	self should: [evaluter evaluteLine: 'V[;]'] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'V[3;]'] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'V[;4]'] raise: GplRuntimeError.	self should: [evaluter evaluteLine: 'V[3;4]'] raise: GplRuntimeError.! !!GdsVectorTest methodsFor: 'tests' stamp: 'kf 5/27/2009 16:20'!testFromLiteral	| result expResult |	expResult := GdsVector fromLiteral: '1. 1. 0. 1.'.	result := GdsVector fromLiteral: '1 TRUE FALSE 1.0'.	self assert: result = expResult.	self should: [GdsVector fromLiteral: '""'] raise: GplSyntaxError .	self should: [GdsVector fromLiteral: '"ABC"'] raise: GplSyntaxError! !!GdsVectorTest methodsFor: 'tests' stamp: 'kf 5/23/2009 19:31'!testIsAcceptableSmalltalkObject	self assert: [(GdsVector isAcceptableSmalltalkObject: 1) = false]		description: 'Vector not aceptable scalar value'.	self assert: 			[(GdsVector isAcceptableSmalltalkObject: #(						1						$a						'abc'						#baka					)) 				= false]		description: 'Vector not aceptable non number value'.	self 		assert: [(GdsVector isAcceptableSmalltalkObject: #(false true false )) = true]		description: 'Vector not aceptable boolean collection'.	self assert: 			[(GdsVector isAcceptableSmalltalkObject: #(						1						2						3						4						5.0						6.0					)) 				= true]		description: 'Vector not aceptable non number value'.	self assert: [(GdsVector isAcceptableSmalltalkObject: #()) = false]		description: 'Vector not aceptable empty collection'! !!GdsVectorTest methodsFor: 'tests' stamp: 'kf 6/11/2009 20:53'!testIsList	self deny: [(GdsVector fromLiteral: '1 1 1 1') isList].! !!GdsVectorTest methodsFor: 'tests' stamp: 'kf 5/25/2009 20:56'!testLength	self assert: [(GdsVector fromLiteral: '1 ') length = 1].	self assert: [(GdsVector fromLiteral: '1 1 ') length = 1].	self assert: [(GdsVector fromLiteral: '1 1 1') length = 1].! !!GdsVectorTest methodsFor: 'tests' stamp: 'kf 5/23/2009 19:31'!testMode	self assert: (GdsVector fromLiteral: '1 1 1 1') mode = 1.	self assert: (GdsVector fromLiteral: '1 1 1 1.0') mode = 3! !!GdsVectorTest methodsFor: 'tests' stamp: 'kf 5/23/2009 19:31'!testShape	self assert: (GdsVector fromLiteral: '1 1 1 1') shape = 4.	self assert: (GdsVector fromLiteral: '1 1 1 1.0 5.0') shape = 5! !!GdsVectorTest methodsFor: 'tests' stamp: 'kf 5/23/2009 19:31'!testSize	self assert: (GdsVector fromLiteral: '1 1 1 1') size = 4.	self assert: (GdsVector fromLiteral: '1 1 1 1.0 5.0') size = 5! !!GdsVectorTest methodsFor: 'tests' stamp: 'kf 5/23/2009 19:31'!testTypeString	self assert: (GdsVector fromLiteral: '1 1 1 1') typeString = 'LOGICAL'.	self assert: (GdsVector fromLiteral: '1 1 1 1.0 5.0') typeString = 'REAL'.	self assert: (GdsVector fromLiteral: '1 1 256 1') typeString = 'INTEGER'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsVectorTest class	instanceVariableNames: ''!GdsTestCase subclass: #GplEvaluterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GplEvaluterTest methodsFor: 'tests' stamp: 'kf 5/25/2009 21:31'!testEvaluteConsoleLine	| input result expResult |	input := '1'.	expResult := '1'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.			input := '1.00000000'.	expResult := '1.'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.			input := '0.0'.	expResult := '0.'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.			input := '0.01'.	expResult := '.01'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.			input := 'FALSE'.	expResult := '0'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.			input := 'TRUE'.	expResult := '1'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.			input := 'true'.	"disallow lowercase"	expResult := '1'.	result := evaluter evaluteConsoleLine: input.	self assert: result ~= expResult.			input := 'false'.	"disallow lowercase"	expResult := '0'.	result := evaluter evaluteConsoleLine: input.	self assert: result ~= expResult.			input := '"GDSII"'.	expResult := 'GDSII'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.			input := '"GDSII"[1]'.	expResult := 'G'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult	     description: 'vector [] operation must impiment'.		input := '1 + 1'.	expResult := '2'.		result := evaluter evaluteConsoleLine: input.	self assert: result ~= expResult.			input := '1 + 1'.	expResult := '2.'.		result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.			input := '+ 1'.	expResult := '1.'.	 "monadic + is a operation like as asFloating "	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult			description: 'monadic + must implement'.				input := '5 - 9'.	expResult := '-4.'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.			input := '5-9'.	expResult := '5 -9'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.		input := '5- 9'.	expResult := '-4.'.	result := evaluter evaluteConsoleLine: input.	self assert: result = expResult.	! !!GplEvaluterTest methodsFor: 'tests' stamp: 'kf 5/27/2009 15:28'!testEvaluteJoinVector	self should: [(evaluter evaluteLine: '"ABC" ,1')] raise: GplError.	self should: [(evaluter evaluteLine: '1, "ABC"')] raise: GplError.		self assert: ((evaluter evaluteLine: '1, 1.0 2') gplString = '1. 1. 2.').	self assert: ((evaluter evaluteLine: '1 1, 2') gplString = '1 1 2').	self assert: ((evaluter evaluteLine: '"ABC", "DEF"') gplString = 'ABCDEF').! !!GplEvaluterTest methodsFor: 'tests' stamp: 'kf 5/27/2009 16:45'!testEvaluteReshape	self should: [evaluter evaluteLine: 'RESHAPE '] raise: GplRuntimeError.	"missing right"	self should: [evaluter evaluteLine: '2 3 RESHAPE '] raise: GplRuntimeError.	"missing left"	self should: [evaluter evaluteLine: 'RESHAPE IOTA 3'] raise: GplRuntimeError.	"NULL Vector"	self should: [evaluter evaluteLine: '"" RESHAPE IOTA 3'] raise: GplRuntimeError.	"Real mode Vector"	self should: [evaluter evaluteLine: '2.0 3.5 RESHAPE IOTA 3'] raise: GplRuntimeError.	"Character mode Vector"	self should: [evaluter evaluteLine: '"A B" RESHAPE IOTA 3'] raise: GplRuntimeError.	"left operands vector max size  =  2"	self should: [evaluter evaluteLine: '2 3 4 RESHAPE IOTA 3'] raise: GplRuntimeError.	"not a array"	self should: [evaluter evaluteLine: '2 3 RESHAPE ("ABC" ; 1 2 3) '] raise: GplRuntimeError.! !GdsTestCase subclass: #GplHandlerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GplHandlerTest methodsFor: 'as yet unclassified' stamp: 'kf 6/5/2009 09:47'!testIsVoid	self assert: [		GplToken builtinMethods allSatisfy: [:each | 			(GplHandler isVoid: each) not]].	! !GdsTestCase subclass: #GplParserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GplParserTest methodsFor: 'tests' stamp: 'kf 5/24/2009 22:32'!testSplitTokens	| input result expResult |	input := 'var$1:=-5 + 3 + 4 + 6 - 10.'.	expResult := { 'var$1' . ':=' . '-5' . '+' . '3' . '+' . '4' . '+' . '6' . '-' . '10.'}.	result := GplParser splitTokens: input.	self assert: result = expResult.			input := 'var$1 := 1 + 1'.	expResult := { 'var$1' . ':=' . '1' . '+' . '1'}.	result := GplParser splitTokens: input.	self assert: result = expResult.			input := 'foo[;6]:=1+1'.	expResult := { 'foo' . '[' . ';' . '6' . ']' . ':=' . '1' . '+' . '1'}.	result := GplParser splitTokens: input.	self assert: result = expResult.		input := '(1234 1235 1236)[6] | Oh Bad Access!!!!'.	expResult := #('(' '1234' '1235' '1236' ')' '[' '6' ']' '| Oh Bad Access!!!!').	result := GplParser splitTokens: input.	self assert: result = expResult.		input := 'LABEL:K:=K+1'.	expResult := #('LABEL' ':' 'K' ':=' 'K' '+' '1').	result := GplParser splitTokens: input.	self assert: result = expResult.	input := 'IF 1 <> 2 THEN'.	expResult := #('IF' '1' '<>' '2' 'THEN').	result := GplParser splitTokens: input.	self assert: result = expResult.		input := '"this is a basic" INDECES_OF "fuck"    '.	expResult := #('"this is a basic"' 'INDECES_OF' '"fuck"').	result := GplParser splitTokens: input.	self assert: result = expResult.	input := 'IF FOO = BAR THEN  BAZENDIF'.	expResult := #('IF' 'FOO' '=' 'BAR' 'THEN' #cr 'BAZ' #cr 'ENDIF').	result := GplParser splitTokens: input.	self assert: result = expResult.		input := '1 1 1 ^+ 2 2 2'.	expResult := #('1' '1' '1' '+' '2' '2' '2').	result := GplParser splitTokens: input.	self assert: result = expResult 	     description: 'can''t eat lineEnding escape character ^'.	input := '(1234 1235 1236)[6] ` Oh Bad Access!!!!'''.	expResult := #('(' '1234' '1235' '1236' ')' '[' '6' ']' '` Oh Bad Access!!!!''').	result := GplParser splitTokens: input.	self assert: result = expResult.	input := 'IF LIB="" THEN "<BEL>"'.	expResult := #('IF' 'LIB' '=' '""' 'THEN' '"<BEL>"').	result := GplParser splitTokens: input.	self assert: result = expResult.	input := '5-9'.	expResult := #('5' '-9').	result := GplParser splitTokens: input.	self assert: result = expResult.	input := '5 - 9'.	expResult := #('5' '-' '9').	result := GplParser splitTokens: input.	self assert: result = expResult.	input := '5- 9'.	expResult := #('5' '-' '9').	result := GplParser splitTokens: input.	self assert: result = expResult.! !GdsTestCase subclass: #GplSyntaxTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Test'!!GplSyntaxTest methodsFor: 'as yet unclassified' stamp: 'kf 5/29/2009 12:00'!check: aGplStatement	| tokens |	tokens := GplParser tokensFrom: aGplStatement.	model checkFromTokens: tokens.! !!GplSyntaxTest methodsFor: 'running' stamp: 'kf 5/29/2009 18:12'!setUp	super setUp.	model := GplSyntax new.	evaluter evaluteLine: 'A:=1'.	model model: evaluter.	! !!GplSyntaxTest methodsFor: 'tests' stamp: 'kf 6/12/2009 08:54'!testAssignCheck	"not presents ':=' "	self shouldnt: [self check: 'PAN  0 0'] raise: GplSyntaxError .	"missing both"	self should: [self check: ':='] raise: GplSyntaxError .	"missing right"	self should: [self check: 'A :='] raise: GplSyntaxError .			"missing left"	self should: [self check: ':= 1'] raise: GplSyntaxError .			"method name"	self should: [self check: 'COORDS := 1'] raise: GplSyntaxError .		"method name with subscript "	self should: [self check: 'COORDS[1] := 1'] raise: GplSyntaxError .			"left operand has function call"	self should: [self check: '(A) := 1'] raise: GplSyntaxError .		"left operand has function call with subscript"	self should: [self check: '(A)[1] := 1'] raise: GplSyntaxError .				"right operand has non return value operation like as procedure"	self should: [self check: 'A := CLOSELIB'] raise: GplSyntaxError .	self should: [self check: 'A := PAN'] raise: GplSyntaxError .	self should: [self check: 'A := MARK'] raise: GplSyntaxError .		"bi context handlers"	self shouldnt: [self check: 'A := SETVIEW'] raise: GplSyntaxError .	"function only"	self shouldnt: [self check: 'A := DAY'] raise: GplSyntaxError .	self shouldnt: [self check: 'A := TOD'] raise: GplSyntaxError .	! !!GplSyntaxTest methodsFor: 'tests' stamp: 'kf 6/5/2009 15:10'!testDeclareCheck	self shouldnt: [self check: ''] raise: GplSyntaxError .	self shouldnt: [self check: String tab] raise: GplSyntaxError .	self shouldnt: [self check: String tab] raise: GplSyntaxError .		self should: [self check: 'A := B'] raise: GplSyntaxError .	self shouldnt: [self check: 'A[1] := 1'] raise: GplSyntaxError .	self shouldnt: [self check: 'B := 1'] raise: GplSyntaxError .	self shouldnt: [self check: '(1 2 3)[1]'] raise: GplSyntaxError .	self shouldnt: [self check: 'A := (1 + 1)'] raise: GplSyntaxError .		"not a command"	self should: [self check: '(SETVIEW2)'] raise: GplSyntaxError .	self should: [self check: 'CORDS'] raise: GplSyntaxError .! !!GplSyntaxTest methodsFor: 'tests' stamp: 'kf 9/9/2012 09:20'!testDepthCheck		"not presents ':=' "	self shouldnt: [self check: 'PAN  0 0'] raise: GplSyntaxError .	"corect case"	self shouldnt: [self check: '([A + 1])'] raise: GplSyntaxError .	"missing right parlen"	self should: [self check: '([A + 1]'] raise: GplSyntaxError .	"missing left parlen"	self should: [self check: '[A + 1])'] raise: GplSyntaxError .	"missing right subscript"	self should: [self check: '([A + 1)'] raise: GplSyntaxError .	"missing left subscript"	self should: [self check: '(A + 1])'] raise: GplSyntaxError .	"empty paren"	self should: [self check: '(   )[A]'] raise: GplSyntaxError .	self should: [self check: '()[A]'] raise: GplSyntaxError .	"empty subscript"	self should: [self check: '(A)[ ]'] raise: GplSyntaxError .	self should: [self check: '(A)[    ]'] raise: GplSyntaxError .		"mismatch "	self should: [self check: '[(A + 1])'] raise: GplSyntaxError .	"mismatch "	self should: [self check: '([A + 1)]'] raise: GplSyntaxError .! !