GdsObject subclass: #GplHandler	instanceVariableNames: 'evaluter'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplHandler methodsFor: 'utility' stamp: 'kf 6/10/2009 11:35'!call: aGplStatement	^evaluter evaluteLine: aGplStatement.! !!GplHandler methodsFor: 'utility' stamp: 'kf 6/8/2009 16:39'!findElementByKeyNumber: aKeyNumber	^self structure liveElements 			detect: [:el | el keyNumber = aKeyNumber]			ifNone: [^self error: ('ELEMENT KEY NOT FOUND: ', aKeyNumber asString)].! !!GplHandler methodsFor: 'utility' stamp: 'kf 5/16/2009 23:29'!floatVector: aFloatCollection		^(aFloatCollection collect: [:each | GdsFloating fromLiteral: (each asString)]) asArray.! !!GplHandler methodsFor: 'utility' stamp: 'kf 6/9/2009 14:13'!fullRedraw	self structureMorph invalidRect: self structureMorph bounds.! !!GplHandler methodsFor: 'utility' stamp: 'kf 5/30/2009 21:23'!illigalKeyNumbers: errorKeys	errorKeys		ifNotEmpty: [			^self error: 'ILLIGAL KEYNUMBERS: ', 			 ((errorKeys collect:[:each | each asString]) joinUsing: ' ')].! !!GplHandler methodsFor: 'utility' stamp: 'kf 5/16/2009 23:27'!integerVector: aIntegerCollection		^(aIntegerCollection collect: [:each | GdsInteger fromLiteral: (each asString)]) asArray.! !!GplHandler methodsFor: 'utility' stamp: 'kf 5/30/2009 21:21'!keyNumbers: keyNumbers doWithElement: aKeyAndElementBlock	| element |	keyNumbers do: [ :each |			element := [self findElementByKeyNumber: each] 			on: Error			do: [:ex | nil].		aKeyAndElementBlock value: each value: element].! !!GplHandler methodsFor: 'utility' stamp: 'kf 5/17/2009 18:03'!nullVector	^GdsNull instance.! !!GplHandler methodsFor: 'utility' stamp: 'kf 5/17/2009 00:27'!stringVector: aByteString	^GdsString fromLiteral: ('"', aByteString,'"')! !!GplHandler methodsFor: 'utility' stamp: 'kf 5/17/2009 17:47'!strings: aByteStringCollection	^self stringVector: (aByteStringCollection joinUsing: String cr).! !!GplHandler methodsFor: 'private' stamp: 'kf 6/8/2009 17:14'!checkStationInstances: aGdsStationUIs	aGdsStationUIs isEmpty 		ifTrue: [^self error: 'STATION DOWN'].	aGdsStationUIs size >= 2		ifTrue: [^self error: 'DUPLICATE STATION ENVIRONMENT ERROR'].	aGdsStationUIs first model		ifNil: [^self error: 'STATION DOWN'].! !!GplHandler methodsFor: 'accessing' stamp: 'kf 5/17/2009 13:35'!currentItem	| station |	station := self station.	station library ifNil: [^self error: 'NO LIBRARY OPEN'].	station structure ifNil: [^self error: 'NO STRUCTURE OPEN'].			^station structure currentItem.! !!GplHandler methodsFor: 'accessing' stamp: 'kf 5/17/2009 17:39'!library	| station library |	station := self station.	library := station library.	library ifNil: [^self error: 'NO LIBRARY OPEN'].	^library.! !!GplHandler methodsFor: 'accessing' stamp: 'kf 5/16/2009 23:04'!methodName	^self class methodName.! !!GplHandler methodsFor: 'accessing' stamp: 'kf 5/28/2009 14:44'!mustStructureOpen	^self currentItem.! !!GplHandler methodsFor: 'accessing' stamp: 'kf 5/17/2009 14:08'!station	| instances |	instances := self stationUIInstances.	self checkStationInstances: instances.	^instances first model.! !!GplHandler methodsFor: 'accessing' stamp: 'kf 5/17/2009 14:07'!stationUIClass	Smalltalk garbageCollect.	^Smalltalk at: #GdsStationUI ifAbsent: [nil].! !!GplHandler methodsFor: 'accessing' stamp: 'kf 5/28/2009 13:09'!stationUIInstances	| clazz |	clazz := self stationUIClass.	clazz ifNil: [^self error: 'GDSFEEL PACKAGE NOT INSTALLED'].	^clazz noGarbageTargetInstances.! !!GplHandler methodsFor: 'accessing' stamp: 'kf 5/18/2009 22:09'!structure	^self station structure.! !!GplHandler methodsFor: 'accessing' stamp: 'kf 11/27/2009 13:57'!structureMorph	| instances |	instances := self stationUIInstances.	instances ifEmpty: [^self error: 'STATION DOWN'].	self checkStationInstances: instances.	^instances first findA: GdsStructureEditorMorph.! !!GplHandler methodsFor: 'accessing' stamp: 'kf 5/28/2009 14:24'!viewport	^self structureMorph viewport.! !!GplHandler methodsFor: 'handler' stamp: 'kf 5/16/2009 22:27'!evaluteToken: aToken! !!GplHandler methodsFor: 'initialize-release' stamp: 'kf 5/16/2009 22:08'!evaluter: aGplEvaluter	evaluter := aGplEvaluter.	! !!GplHandler methodsFor: 'checker' stamp: 'kf 5/28/2009 17:26'!illigalCoordinate	^self error: 'ILLIGAL COORDINATE VALUE'.! !!GplHandler methodsFor: 'checker' stamp: 'kf 5/28/2009 17:29'!mustBeCoordinatable: aGdsArray	(#('CHAR' 'LIST' 'NULL') includes: aGdsArray typeString)		 ifTrue: [^self illigalCoordinate].! !!GplHandler methodsFor: 'checker' stamp: 'kf 6/12/2009 09:11'!mustbeString: aGplValue	aGplValue isCharVector		ifFalse: [^self error: 'ONLY SPECIFIED CHARACTER VECTOR'].	! !!GplHandler methodsFor: 'testing' stamp: 'kf 5/21/2009 22:44'!isFunctionAllowed	^self class isFunctionAllowed.! !!GplHandler methodsFor: 'testing' stamp: 'kf 5/21/2009 22:44'!isNiladicAllowed	^self class isNiladicAllowed.! !!GplHandler methodsFor: 'marking' stamp: 'kf 5/30/2009 21:24'!markByKeys: keyNumbers	| points errorKeys  |	points := OrderedCollection new.	errorKeys := OrderedCollection new.	self 		keyNumbers: keyNumbers 		doWithElement: [:key :element| 			element				ifNil: [errorKeys add: key]				ifNotNil: [points add: element xy]].	self illigalKeyNumbers: errorKeys.	self markPoints: points asArray.! !!GplHandler methodsFor: 'marking' stamp: 'kf 5/30/2009 20:46'!markPoints: aPoints	aPoints ifEmpty: [^self].	self structureMorph setVisible: true forKey:  #mark.	aPoints do: [:each |		self structureMorph mark: each.].	self structureMorph invalidRect: self structureMorph bounds.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplHandler class	instanceVariableNames: ''!!GplHandler class methodsFor: 'accessing' stamp: 'kf 5/28/2009 13:47'!commandNames	^(GplMultiHandler commandNames, GplSingleHandler commandNames)! !!GplHandler class methodsFor: 'accessing' stamp: 'kf 5/16/2009 22:10'!methodName	^''.	! !!GplHandler class methodsFor: 'accessing' stamp: 'kf 6/8/2009 14:20'!methodNames	^(GplMultiHandler methodNames, GplSingleHandler methodNames)! !!GplHandler class methodsFor: 'accessing' stamp: 'kf 5/29/2009 17:00'!voidCommandNames	^self commandNames select: [:each | self isVoid: each]! !!GplHandler class methodsFor: 'instance creation' stamp: 'kf 5/16/2009 22:17'!fromCommand: aCommandName evaluter: aGplEvaluter	| clazz |	clazz := self lookupHandlerClass: aCommandName.	clazz ifNil: [^nil].	^clazz new evaluter: aGplEvaluter.	! !!GplHandler class methodsFor: 'testing' stamp: 'kf 5/17/2009 14:25'!hasCommandName: aCommandName	^(self lookupHandlerClass: aCommandName) isNil not. ! !!GplHandler class methodsFor: 'testing' stamp: 'kf 5/21/2009 22:44'!isFunctionAllowed	^false.! !!GplHandler class methodsFor: 'testing' stamp: 'kf 5/21/2009 22:52'!isFunctionAllowed: aCommandName	^self valueTestFor:  aCommandName selector: #isFunctionAllowed! !!GplHandler class methodsFor: 'testing' stamp: 'kf 5/21/2009 22:45'!isNiladicAllowed	^false.! !!GplHandler class methodsFor: 'testing' stamp: 'kf 5/21/2009 22:52'!isNiladicAllowed: aCommandName	^self valueTestFor:  aCommandName selector: #isNiladicAllowed	! !!GplHandler class methodsFor: 'testing' stamp: 'kf 6/5/2009 09:44'!isVoid: aCommandName	(GplToken isBuiltinMethod: aCommandName)		ifTrue: [^false].	^(self isFunctionAllowed: aCommandName) not.! !!GplHandler class methodsFor: 'testing' stamp: 'kf 5/21/2009 22:54'!noArgReturnValueEnabled: aCommandName	^self isFunctionAllowed and: [self isNiladicAllowed].! !!GplHandler class methodsFor: 'testing' stamp: 'kf 5/21/2009 22:51'!valueTestFor: aCommandName selector: aSelector	| clazz |	clazz := self lookupHandlerClass: aCommandName.	^(clazz ifNil: [self] ifNotNil:[clazz]) perform: aSelector.! !!GplHandler class methodsFor: 'private' stamp: 'kf 5/28/2009 13:20'!lookupHandlerClass: aCommandName	{ GplMultiHandler . GplSingleHandler }		do: [:clazz | 			| handlerClass |			handlerClass := clazz lookupHandlerClass: aCommandName.			handlerClass ifNotNil: [^handlerClass]].	^nil.	! !GplHandler subclass: #GplMultiHandler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplMultiHandler methodsFor: 'handler' stamp: 'kf 5/28/2009 13:36'!evaluteToken: aToken	| selector |	selector := self class selectorForMethodName: aToken fragment.	^self perform: selector with: aToken! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplMultiHandler class	instanceVariableNames: ''!!GplMultiHandler class methodsFor: 'accessing' stamp: 'kf 5/28/2009 13:33'!associateArray	^self subclassResponsibility .	! !!GplMultiHandler class methodsFor: 'accessing' stamp: 'kf 5/28/2009 13:47'!commandNames	| names |	names := OrderedCollection new.	self allSubclasses do: [:clazz |		 clazz methodNames do: [:mname |			names add: mname asUppercase]].	^names asArray.! !!GplMultiHandler class methodsFor: 'accessing' stamp: 'kf 5/29/2009 10:09'!functionNames	"self functionNames"	| colNames |	colNames := OrderedCollection new.	self allSubclasses do: [:clazz | 		clazz methodNames do: [:each | 			(clazz isFunctionAllowed: each)				ifTrue: [colNames add: each] ]].	^colNames asArray.! !!GplMultiHandler class methodsFor: 'accessing' stamp: 'kf 5/28/2009 13:39'!methodNames	^self associateArray collect: [:each | each key ]! !!GplMultiHandler class methodsFor: 'accessing' stamp: 'kf 5/29/2009 10:10'!procedureNames	"self procedureNames"	| colNames |	colNames := OrderedCollection new.	self allSubclasses do: [:clazz | 		clazz methodNames do: [:each | 			(clazz isFunctionAllowed: each)				ifFalse: [colNames add: each] ]].	^colNames asArray.! !!GplMultiHandler class methodsFor: 'testing' stamp: 'kf 5/29/2009 10:02'!isFunctionAllowed: aCommandName	self subclassResponsibility ! !!GplMultiHandler class methodsFor: 'private' stamp: 'kf 5/28/2009 13:14'!lookupHandlerClass: aCommandName	^self allSubclasses		detect: [:clazz | 			clazz methodNames				anySatisfy: [:each | each sameAs: aCommandName]] ifNone: [nil]	! !!GplMultiHandler class methodsFor: 'private' stamp: 'kf 5/28/2009 17:36'!selectorForMethodName: aCommandName	^(self selectorMap at: aCommandName asUppercase)! !!GplMultiHandler class methodsFor: 'private' stamp: 'kf 5/28/2009 13:33'!selectorMap	^Dictionary newFrom: self associateArray .	! !GplMultiHandler subclass: #GplCurrentItemNoArgHandler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplCurrentItemNoArgHandler methodsFor: 'handler' stamp: 'kf 5/28/2009 15:28'!evaluteToken: aToken	| selector |	selector := self class selectorForMethodName: aToken fragment.	self currentItem perform: selector.	^self nullVector.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplCurrentItemNoArgHandler class	instanceVariableNames: ''!!GplCurrentItemNoArgHandler class methodsFor: 'accessing' stamp: 'kf 7/15/2009 13:59'!associateArray	^{	'UNGET' -> #unget . 	'PUT' -> #put.	'ITEMREVERSE' -> #reverseVertices}! !!GplCurrentItemNoArgHandler class methodsFor: 'testing' stamp: 'kf 5/29/2009 10:03'!isFunctionAllowed: aCommandName	^false! !GplMultiHandler subclass: #GplDateTimeHandler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplDateTimeHandler methodsFor: 'handler' stamp: 'kf 5/28/2009 16:02'!day: aToken	| date |	date := Date today.	^ GdsVector 		withAll: (self integerVector: { 						(date monthIndex).						(date dayOfMonth).						(date year asString)})! !!GplDateTimeHandler methodsFor: 'handler' stamp: 'kf 5/28/2009 16:02'!tod: aToken	| time |	time := Time now.	^ GdsVector 		withAll: (self integerVector: { 						(time hour).						(time minute).						(time second)})! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplDateTimeHandler class	instanceVariableNames: ''!!GplDateTimeHandler class methodsFor: 'accessing' stamp: 'kf 5/28/2009 16:02'!associateArray	^{'TOD' -> #tod: . 'DAY' -> #day: }! !!GplDateTimeHandler class methodsFor: 'testing' stamp: 'kf 5/28/2009 13:41'!isFunctionAllowed	^true! !!GplDateTimeHandler class methodsFor: 'testing' stamp: 'kf 5/29/2009 10:03'!isFunctionAllowed: aCommandName	^true! !!GplDateTimeHandler class methodsFor: 'testing' stamp: 'kf 5/28/2009 13:41'!isNiladicAllowed	^true! !GplMultiHandler subclass: #GplFunctions	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplFunctions methodsFor: 'handler' stamp: 'kf 5/30/2009 17:50'!ceKey: aToken	| gv1 smVec element smPoint |	self mustStructureOpen.	gv1 := evaluter popArg asGplValue asVector.	smVec := gv1 asSmalltalkValue.	smVec size = 2 ifFalse: [^self illigalCoordinate].	smPoint := smVec first@smVec second.	element := self structure findNearestElementByPoint: smPoint.	^element		ifNil: [self nullVector]		ifNotNil: [element keyNumber asGdsValue ]	! !!GplFunctions methodsFor: 'handler' stamp: 'kf 5/30/2009 20:24'!idKeys: aToken	self mustStructureOpen.	^(self structure idSelection keyNumbers) asArray asGdsValue. ! !!GplFunctions methodsFor: 'handler' stamp: 'kf 5/30/2009 17:40'!keyCe: aToken	| gv1 smVec element smPoint |	self mustStructureOpen.	gv1 := evaluter popArg asGplValue asVector.	smVec := gv1 asSmalltalkValue.	smVec size = 1 ifFalse: [^self error: 'ARGUMENT MUST KEYNUMBER ONLY'].	element := self findElementByKeyNumber: smVec first.	smPoint := element xy.	^{smPoint x . smPoint y } asGdsValue.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplFunctions class	instanceVariableNames: ''!!GplFunctions class methodsFor: 'accessing' stamp: 'kf 5/30/2009 20:24'!associateArray	^{	'IDKEYS' -> #idKeys: .	'KEYCE' -> #keyCe: .	'CEKEY' -> #ceKey: }! !!GplFunctions class methodsFor: 'testing' stamp: 'kf 5/30/2009 17:44'!isFunctionAllowed	^true! !!GplFunctions class methodsFor: 'testing' stamp: 'kf 5/30/2009 17:28'!isFunctionAllowed: aCommandName	^true! !GplMultiHandler subclass: #GplMarkHandler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplMarkHandler methodsFor: 'handler' stamp: 'kf 5/30/2009 20:51'!keyMark: aToken	| arg1 keyNumbers |	self mustStructureOpen.	arg1 := evaluter popArg asGplValue.	keyNumbers := arg1 asVector asSmalltalkValue .	self markByKeys: keyNumbers.	^self nullVector. 	! !!GplMarkHandler methodsFor: 'handler' stamp: 'kf 5/30/2009 20:33'!mark: aToken	| arg1 gv1 numRow mat points |	self mustStructureOpen.	arg1 := evaluter popArg asGplValue.	gv1 := arg1 asVector.	self mustBeCoordinatable: gv1.	gv1 size \\ 2 = 0 ifFalse: [^self illigalCoordinate].	numRow := gv1 size // 2.	mat := Matrix  rows: numRow columns: 2 contents: gv1 asSmalltalkValue.	self structureMorph setVisible: true forKey:  #mark.	points := OrderedCollection new.	1 to: mat rowCount do: [:rowIndex |		points add: ((mat at: rowIndex at: 1) @ (mat at: rowIndex at: 2))].	self markPoints: points.	 ^self nullVector. 	! !!GplMarkHandler methodsFor: 'handler' stamp: 'kf 11/27/2009 13:57'!markElementKeys: aToken	self mustStructureOpen.	self structureMorph setVisible: true forKey:  #mark.	self structureMorph showsElementKey: true.	self structureMorph invalidRect: self structureMorph bounds.	 ^self nullVector. 	! !!GplMarkHandler methodsFor: 'handler' stamp: 'kf 5/30/2009 14:43'!remove: aToken	self mustStructureOpen.	self structureMorph clearMarker.	 ^self nullVector. 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplMarkHandler class	instanceVariableNames: ''!!GplMarkHandler class methodsFor: 'accessing' stamp: 'kf 5/30/2009 20:47'!associateArray	^{	'KEYMARK' -> #keyMark: . 	'MARK' -> #mark: . 	'REMOVE' -> #remove: . 	'MARKELKEYS'-> #markElementKeys:}! !!GplMarkHandler class methodsFor: 'testing' stamp: 'kf 5/29/2009 10:03'!isFunctionAllowed: aCommandName	^false! !GplHandler subclass: #GplSingleHandler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplSingleHandler class	instanceVariableNames: ''!!GplSingleHandler class methodsFor: 'accessing' stamp: 'kf 5/28/2009 13:44'!commandNames	^((self allSubclasses collect: [:clazz | clazz methodName asUppercase])		reject: [:each | each isEmpty]) asArray! !!GplSingleHandler class methodsFor: 'accessing' stamp: 'kf 5/29/2009 09:59'!functionNames	"self functionNames"	^((self allSubclasses select: [:clazz | 			clazz isFunctionAllowed ])		collect: [:each | each methodName]) asArray! !!GplSingleHandler class methodsFor: 'accessing' stamp: 'kf 5/28/2009 13:17'!lookupHandlerClass: aCommandName	^self allSubclasses detect: [:clazz | clazz methodName sameAs: aCommandName] ifNone: [nil]	! !!GplSingleHandler class methodsFor: 'accessing' stamp: 'kf 6/8/2009 14:20'!methodNames	^((self allSubclasses collect: [:clazz | clazz methodName asUppercase])		reject: [:each | each isEmpty]) asArray! !!GplSingleHandler class methodsFor: 'accessing' stamp: 'kf 5/29/2009 09:57'!procedureNames	"self procedureNames"	^((self allSubclasses select: [:clazz | 			clazz isFunctionAllowed not])		collect: [:each | each methodName]) asArray! !GplSingleHandler subclass: #GplBiContextHandler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplBiContextHandler methodsFor: 'handler' stamp: 'kf 5/28/2009 18:16'!evaluteToken: aToken 	^(self isFunctionCall: aToken)		ifTrue: [self functionCall: aToken]		ifFalse: [self procedureCall: aToken]	! !!GplBiContextHandler methodsFor: 'handler' stamp: 'kf 5/28/2009 18:15'!functionCall: aToken	self subclassResponsibility! !!GplBiContextHandler methodsFor: 'handler' stamp: 'kf 5/28/2009 18:15'!procedureCall: aToken	self subclassResponsibility! !!GplBiContextHandler methodsFor: 'testing' stamp: 'kf 5/28/2009 18:14'!isFunctionCall: aToken 	^aToken leftTokens isEmpty not! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplBiContextHandler class	instanceVariableNames: ''!!GplBiContextHandler class methodsFor: 'accessing' stamp: 'kf 5/29/2009 10:13'!functionNames	^self methodNames! !!GplBiContextHandler class methodsFor: 'accessing' stamp: 'kf 5/29/2009 10:14'!procedureNames	^self methodNames! !!GplBiContextHandler class methodsFor: 'testing' stamp: 'kf 5/29/2009 16:58'!isFunctionAllowed	^true.! !GplSingleHandler subclass: #GplCloseBetaLib	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplCloseBetaLib methodsFor: 'handler' stamp: 'kf 6/3/2009 08:45'!evaluteToken: aToken	| clazz instances|	self station structure		ifNotNil: [self call: 'TSTRUCT'].	clazz := self stationUIClass.	clazz 		ifNotNil: [			instances := clazz noGarbageTargetInstances. 			instances do: [:each | each delete.].			Smalltalk garbageCollect ].	^self nullVector.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplCloseBetaLib class	instanceVariableNames: ''!!GplCloseBetaLib class methodsFor: 'accessing' stamp: 'kf 6/18/2009 16:22'!methodName	"@deprecated "	^''! !GplSingleHandler subclass: #GplCloseLib	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplCloseLib methodsFor: 'as yet unclassified' stamp: 'kf 6/18/2009 16:07'!evaluteToken: aToken	| clazz instances|	self station structure		ifNotNil: [self call: 'TSTRUCT'].	clazz := self stationUIClass.	clazz 		ifNotNil: [			instances := clazz noGarbageTargetInstances. 			instances do: [:each | each delete.].			Smalltalk garbageCollect ].	^self nullVector.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplCloseLib class	instanceVariableNames: ''!!GplCloseLib class methodsFor: 'as yet unclassified' stamp: 'kf 6/18/2009 16:22'!methodName	^'CLOSELIB'! !GplSingleHandler subclass: #GplCommands	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplCommands methodsFor: 'handler' stamp: 'kf 5/17/2009 17:55'!evaluteToken: aToken	^self strings: (GplHandler commandNames sort)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplCommands class	instanceVariableNames: ''!!GplCommands class methodsFor: 'accessing' stamp: 'kf 5/17/2009 00:19'!methodName	^'COMMANDS'! !GplSingleHandler subclass: #GplCoords	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplCoords methodsFor: 'handler' stamp: 'kf 5/23/2009 19:31'!evaluteToken: aToken 	| values |	values := OrderedCollection new.	self currentItem vertices do: 			[:pt | 			values add: pt x.			values add: pt y].	values ifEmpty: [^ self nullVector].	^ GdsMatrix 		fromGdsVector: (GdsVector withAll: (self floatVector: values))		row: self currentItem vertices size		col: 2! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplCoords class	instanceVariableNames: ''!!GplCoords class methodsFor: 'testing' stamp: 'kf 5/21/2009 22:45'!isFunctionAllowed	^true.	! !!GplCoords class methodsFor: 'testing' stamp: 'kf 5/21/2009 22:45'!isNiladicAllowed	^true.	! !!GplCoords class methodsFor: 'accessing' stamp: 'kf 5/16/2009 22:09'!methodName	^'COORDS'! !GplSingleHandler subclass: #GplDataExtent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplDataExtent methodsFor: 'handler' stamp: 'kf 5/30/2009 21:37'!evaluteToken: aToken 	| numArgs |	self mustStructureOpen.	numArgs := evaluter numArgs: aToken.	numArgs = 0		ifTrue: [			^self fullExtent].	^self keysExtent.		! !!GplDataExtent methodsFor: 'handler' stamp: 'kf 5/30/2009 21:32'!fullExtent	self structure liveElements		ifEmpty: [^self nullVector].	^GdsMatrix fromRectangle:  self structure dataExtentForElements.	! !!GplDataExtent methodsFor: 'handler' stamp: 'kf 5/30/2009 21:41'!keysExtent	| gv1 smVec elements errorKeys smBounds |	gv1 := evaluter popArg asGplValue.	smVec := gv1 asVector asSmalltalkValue.	elements := OrderedCollection new.	errorKeys := OrderedCollection new.	self 		keyNumbers: smVec 		doWithElement: [:key :element| 			element				ifNil: [errorKeys add: key]				ifNotNil: [elements add: element]].	self illigalKeyNumbers: errorKeys.	elements ifEmpty: [^self nullVector].	smBounds := self structure 		lookupDataExtentForElementsChooserBlock: [:element |			elements includes: element].	^GdsMatrix fromRectangle: smBounds. 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplDataExtent class	instanceVariableNames: ''!!GplDataExtent class methodsFor: 'testing' stamp: 'kf 5/30/2009 09:49'!isFunctionAllowed	^true.! !!GplDataExtent class methodsFor: 'testing' stamp: 'kf 5/30/2009 09:50'!isNiladicAllowed	^true.	! !!GplDataExtent class methodsFor: 'accessing' stamp: 'kf 5/30/2009 09:49'!methodName	^'DATAEXTENT'! !GplSingleHandler subclass: #GplGet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplGet methodsFor: 'as yet unclassified' stamp: 'kf 5/30/2009 15:00'!usage	^'usage: GET {X} {Y}  or GET {KEY}'! !!GplGet methodsFor: 'handler' stamp: 'kf 5/30/2009 17:37'!evaluteToken: aToken	| gv1 vec smVec element |	self mustStructureOpen. 	self currentItem getEnabled		ifFalse: [^self error: 'ITEM NOT EMPTY'].		gv1 := evaluter popArg asGplValue.	vec := gv1 asVector.	(#(1 2) includes: (vec size)) ifFalse: [^self error: self usage ].	smVec := vec asSmalltalkValue.	(smVec size = 2)		ifTrue: [			element := self structure 				findNearestElementByPoint: (smVec first@smVec second).			element				ifNil: [					^self error: ('CANNT GET ELEMENT AT: <1s> <2s>' 						expandMacrosWith:  smVec first  with: smVec second asString)]				ifNotNil: [self currentItem get: element]].	(smVec size = 1)		ifTrue: [			element := self findElementByKeyNumber: smVec first.			self currentItem get: element].				^self nullVector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplGet class	instanceVariableNames: ''!!GplGet class methodsFor: 'accessing' stamp: 'kf 5/30/2009 14:45'!methodName	^'GET'	! !GplBiContextHandler subclass: #GplGridMultiply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplGridMultiply methodsFor: 'as yet unclassified' stamp: 'kf 6/10/2009 10:36'!functionCall: aToken	^self viewport grid displayMultiply asInteger asGdsValue! !!GplGridMultiply methodsFor: 'as yet unclassified' stamp: 'kf 6/10/2009 13:42'!procedureCall: aToken	| gv1 vec smVec value |	self viewport grid.	(evaluter numArgs: aToken) = 0		ifTrue: [			value := self call: 'GRID (EXPINPUT "Enter Grid Multiplier Count: ")'.]		ifFalse: [			gv1 := evaluter popArg asGplValue.			vec := gv1 asVector.			smVec := vec asSmalltalkValue.			(smVec size = 1)				ifFalse: [^self error: 'ILLIGAL ARGUMENT '].			value := smVec first.].	value fractionPart = 0.0		ifFalse: [^self error: 'SCALE MUST BE INTEGER VALUE'].	self viewport grid displayMultiply:  value.			self fullRedraw.	^self nullVector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplGridMultiply class	instanceVariableNames: ''!!GplGridMultiply class methodsFor: 'as yet unclassified' stamp: 'kf 6/10/2009 10:35'!methodName	^'GRID'! !GplBiContextHandler subclass: #GplGridScale	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplGridScale methodsFor: 'as yet unclassified' stamp: 'kf 6/9/2009 13:58'!functionCall: aToken	^self viewport grid asArray asGdsValue! !!GplGridScale methodsFor: 'as yet unclassified' stamp: 'kf 6/10/2009 13:27'!procedureCall: aToken	| gv1 vec smVec |	self viewport grid.	gv1 := evaluter popArg asGplValue.	vec := gv1 asVector.	smVec := vec asSmalltalkValue.	(#(1 2 4) includes: (smVec size))		ifFalse: [^self error: 'ILLIGAL ARGUMENT '].	smVec size = 1		ifTrue: [			 self viewport grid scale: smVec first asPoint].	smVec size = 2		ifTrue: [			 self viewport grid scale: (smVec first@smVec second)].	smVec size = 4		ifTrue: [			 self viewport				grid 					offset: (smVec first@smVec second);					scale: (smVec third@smVec fourth).].			self fullRedraw.	^self nullVector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplGridScale class	instanceVariableNames: ''!!GplGridScale class methodsFor: 'as yet unclassified' stamp: 'kf 6/9/2009 10:37'!methodName	^'GSCALE'! !GplBiContextHandler subclass: #GplInitLib	instanceVariableNames: 'libname dbu unit'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplInitLib methodsFor: 'as yet unclassified' stamp: 'kf 6/12/2009 11:21'!extractArguments	| arg1 gv1 |	arg1 := evaluter popArg.	gv1 := arg1 asGplValue.	gv1 isList 		ifFalse: [^self error: self usageString].	gv1 length = 6		ifFalse: [^self error: self usageString].	libname := gv1 at: 1.	dbu := gv1 at: 4.	unit := gv1 at: 5.	self extractLibName.	self extractDatabaseUnits.		self extractUnitString.! !!GplInitLib methodsFor: 'as yet unclassified' stamp: 'kf 6/12/2009 15:59'!extractDatabaseUnits	dbu := [dbu asScalar] 		on: Error 		do: [:ex | 			dbu := nil.			^self error: 'DBU MUST BE SCALAR VALUE']. 	dbu := dbu asSmalltalkValue.	GdsLibrary checkDatabaseUnit: dbu.! !!GplInitLib methodsFor: 'as yet unclassified' stamp: 'kf 6/12/2009 15:58'!extractLibName	libname isCharVector		 ifFalse: [			libname := nil.			^self error: 'LIBRARY NAME MUST BE STRING'].	libname := 	libname gplString.	GdsLibrary checkLibName: libname.! !!GplInitLib methodsFor: 'as yet unclassified' stamp: 'kf 6/12/2009 16:04'!extractUnitString	unit isCharVector		 ifFalse: [			unit := nil.			^self error: 'UNIT  MUST BE STRING'].	unit := unit gplString.	GdsLibrary checkUnitString: unit.! !!GplInitLib methodsFor: 'as yet unclassified' stamp: 'kf 6/11/2009 14:19'!functionCall: aToken! !!GplInitLib methodsFor: 'as yet unclassified' stamp: 'kf 6/15/2009 21:07'!procedureCall: aToken 	| lib |	(evaluter numArgs: aToken) < 1 ifTrue: [ ^ self error: 'MISSING ARGUMENT' ].	self extractArguments.	lib := GdsLibrary 		initializeName: libname		databaseUnits: dbu		unitString: unit.	^ self nullVector! !!GplInitLib methodsFor: 'as yet unclassified' stamp: 'kf 6/11/2009 17:54'!usageString	^ 'INITLIB {filename};"";"";{dbu};{unit};""'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplInitLib class	instanceVariableNames: ''!!GplInitLib class methodsFor: 'as yet unclassified' stamp: 'kf 6/11/2009 14:18'!methodName	^'INITLIB'! !GplSingleHandler subclass: #GplIota	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplIota methodsFor: 'handler' stamp: 'kf 5/27/2009 16:17'!evaluteToken: aToken 	| v step start end values |	(evaluter numArgs: aToken) < 1 		ifTrue: [^ self runtimeError: 'MISSING ARGUMENT for IOTA'].	v := evaluter popArg asGplValue asVector.	(v size > 3 or: [v size < 1]) 		ifTrue: 			[^ self runtimeError: 'ILLIGAL ARGUMENT SIZE: {m} or {n} {m} or {n} {step} {m}'].	(#('BOOLEAN' 'INTEGER' ) includes: v typeString) 		ifFalse: [^ self runtimeError: 'ILLIGAL NUMERIC INPUT'].	step := 1.	start := 1.	end := 1.	v size = 1 ifTrue: [end := (v at: 1) asSmalltalkValue].	v size = 2 		ifTrue: 			[start := (v at: 1) asSmalltalkValue.			end := (v at: 2) asSmalltalkValue].	v size = 3 		ifTrue: 			[start := (v at: 1) asSmalltalkValue.			step := (v at: 2) asSmalltalkValue.			end := (v at: 3) asSmalltalkValue].	values := (start to: end by: step) collect: [:v1 | v1].	^ GdsVector 		withAll: (values collect: [:v2 | GdsInteger fromLiteral: v2 asString])! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplIota class	instanceVariableNames: ''!!GplIota class methodsFor: 'testing' stamp: 'kf 5/21/2009 22:46'!isFunctionAllowed	^true.	! !!GplIota class methodsFor: 'accessing' stamp: 'kf 5/16/2009 23:39'!methodName	^'IOTA'	! !GplSingleHandler subclass: #GplListLib	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplListLib methodsFor: 'handler' stamp: 'kf 5/20/2009 16:37'!evaluteToken: aToken	| arg1 gdsPattern sqPattern names |	names := self library structureNames.	((evaluter numArgs: aToken) > 0)		ifTrue: [			arg1 := evaluter popArg asGplValue.			self mustbeString: arg1.			gdsPattern := arg1 gplString.			"TODO: real implements"			sqPattern := gdsPattern copyReplaceAll: '-' with: '*'.			names := names select: [: each | sqPattern match: each ].].			^self strings: names.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplListLib class	instanceVariableNames: ''!!GplListLib class methodsFor: 'accessing' stamp: 'kf 5/17/2009 17:34'!methodName	^'LISTLIB'! !GplSingleHandler subclass: #GplOpenBetaLib	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplOpenBetaLib methodsFor: 'handler' stamp: 'kf 6/9/2009 10:13'!evaluteToken: aToken	| clazz |	clazz := self stationUIClass.	clazz 		ifNotNil: [			Semaphore forMutualExclusion 				critical: [					clazz openWithInform: false]].	^self nullVector.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplOpenBetaLib class	instanceVariableNames: ''!!GplOpenBetaLib class methodsFor: 'accessing' stamp: 'kf 6/18/2009 16:19'!methodName	"@deprecated"	^''! !GplSingleHandler subclass: #GplOpenLib	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplOpenLib methodsFor: 'as yet unclassified' stamp: 'kf 6/18/2009 16:30'!evaluteToken: aToken	| clazz arg1 libName |	(evaluter numArgs: aToken) < 1 		ifTrue: [^ self runtimeError: 'MISSING LIBRARY NAME'].	arg1 := evaluter popArg asGplValue.	self mustbeString: arg1.	libName := arg1 gplString.	(GdsLibrary exists: libName)		ifFalse: [^self error: 'LIBRARY NOT FOUND: ', libName].	clazz := self stationUIClass.	clazz 		ifNotNil: [			"Semaphore forMutualExclusion 				critical: ["					clazz openWithInform: false.					self station openLibraryNamed:  libName"]"].	^self nullVector.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplOpenLib class	instanceVariableNames: ''!!GplOpenLib class methodsFor: 'as yet unclassified' stamp: 'kf 6/18/2009 16:06'!methodName	^'OPENLIB'! !GplSingleHandler subclass: #GplOpenStructure	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplOpenStructure methodsFor: 'handler' stamp: 'kf 6/9/2009 14:00'!evaluteToken: aToken	| arg1 struct structureName |	Smalltalk garbageCollect.	(evaluter numArgs: aToken)  = 0		ifTrue: [^self error: 'STRUCTURE NAME NOT SPECIFIED'].	self station structure		ifNotNil: [^self error: 'STRUCTURE ALREADY OPEND: ', self station structure name].	arg1 := evaluter popArg asGplValue.	self mustbeString: arg1.	structureName := arg1 gplString.	struct :=  self station library structureNamed: structureName.	struct ifNil: [^self error: 'STRUCTURE NOT FOUND: ', structureName].	Semaphore forMutualExclusion 		critical: [self station ostructNames: [: names | structureName]].	^self nullVector.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplOpenStructure class	instanceVariableNames: ''!!GplOpenStructure class methodsFor: 'accessing' stamp: 'kf 5/17/2009 18:20'!methodName	^'OSTRUCT'! !GplBiContextHandler subclass: #GplSetView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplSetView methodsFor: 'handler' stamp: 'kf 5/30/2009 10:00'!functionCall: aToken	^GdsMatrix 		fromOrigin:  self viewport  worldViewOrigin		corner: self viewport  worldViewCorner! !!GplSetView methodsFor: 'handler' stamp: 'kf 5/28/2009 20:31'!procedureCall: aToken	| gv1 vec smVec worldBounds |	gv1 := evaluter popArg asGplValue.	vec := gv1 asVector.	vec size = 4 ifFalse: [^self illigalCoordinate ].	smVec := vec asSmalltalkValue.	worldBounds := 		GeometryUtils lookupDataBounds: {(smVec first @smVec second) . (smVec third @smVec fourth)}.	worldBounds extent isZero ifTrue: [^self illigalCoordinate ].	self viewport viewBounds: worldBounds.	^self nullVector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplSetView class	instanceVariableNames: ''!!GplSetView class methodsFor: 'accessing' stamp: 'kf 5/28/2009 18:31'!methodName	^'SETVIEW'! !GplSingleHandler subclass: #GplTerminateStructure	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplTerminateStructure methodsFor: 'handler' stamp: 'kf 5/18/2009 22:22'!evaluteToken: aToken	self station structure ifNil: [^self error: 'NO STRUCTURE OPEN.'].	self currentItem putEnabled		ifTrue: [^self error: 'ITEM NOT EMPTY. TO USE [PUT] or [PUTALL] or [UNGET]']. 	self  structure idSelection isEmpty		ifFalse: [^self error: 'ELEMENTS STILL IN ID SPACE . TO USE [UNID] or [IDCLEAR]'].	self station tstruct.		^self nullVector.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplTerminateStructure class	instanceVariableNames: ''!!GplTerminateStructure class methodsFor: 'accessing' stamp: 'kf 5/18/2009 21:37'!methodName	^'TSTRUCT'! !GplSingleHandler subclass: #GplTextInput	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplTextInput methodsFor: 'handler' stamp: 'kf 6/10/2009 13:08'!evaluteToken: aToken 	evaluter hasSuspendContext		ifFalse: [			^self signalPrompt: thisContext].	^self signalResult.! !!GplTextInput methodsFor: 'handler' stamp: 'kf 6/12/2009 09:12'!signalPrompt: aContext	| arg1 gv1 |	arg1 := evaluter popArg.	gv1 := arg1 asGplValue.	gv1 isCharVector		ifFalse: [^self error: 'PROMPT MUST BE STRING'].	evaluter pushSuspendContext: aContext.		^GplPromptException new signal: 	gv1 gplString! !!GplTextInput methodsFor: 'handler' stamp: 'kf 6/10/2009 11:51'!signalResult	| smPrompt |	smPrompt := evaluter popResult.	self assert: smPrompt isNil not.	"lastContext explore."	^smPrompt asGdsValue.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplTextInput class	instanceVariableNames: ''!!GplTextInput class methodsFor: 'as yet unclassified' stamp: 'kf 6/5/2009 15:45'!isFunctionAllowed	^true.	! !!GplTextInput class methodsFor: 'as yet unclassified' stamp: 'kf 6/5/2009 15:46'!methodName	^'TEXTINPUT'! !GplTextInput subclass: #GplExpInput	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplExpInput methodsFor: 'as yet unclassified' stamp: 'kf 6/10/2009 16:12'!signalResult	| textResult vec |	textResult := super signalResult.	textResult = GdsNull instance ifTrue: [^GdsNull instance].	vec := GdsVector fromLiteral: (textResult gplString).	vec size = 1 ifTrue: [^vec elements first].	^vec! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplExpInput class	instanceVariableNames: ''!!GplExpInput class methodsFor: 'as yet unclassified' stamp: 'kf 6/10/2009 13:01'!methodName	^'EXPINPUT'! !GplMultiHandler subclass: #GplVertexHandler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplVertexHandler methodsFor: 'handler' stamp: 'kf 7/15/2009 15:44'!deleteVertex: aToken	| arg1 gv1 ce smVec analisysResult targetIndex |	self mustStructureOpen.	arg1 := evaluter popArg asGplValue.	gv1 := arg1 asVector.	self mustBeCoordinatable: gv1.	gv1 size  =  2 ifFalse: [^self illigalCoordinate].	smVec := gv1 asSmalltalkValue.	ce := (smVec at: 1)@ (smVec at: 2).	analisysResult := GeometryUtils 		analisysSegmentsAt: ce pointArray: self currentItem vertices.		targetIndex := GeometryUtils lookupVertexIndex: analisysResult.	self currentItem removeVertexAt: targetIndex.	^self nullVector. 		! !!GplVertexHandler methodsFor: 'handler' stamp: 'kf 7/15/2009 15:52'!deleteVertexIndexed: aToken	| arg1 gv1 smVec targetIndex |	self mustStructureOpen.	arg1 := evaluter popArg asGplValue.	gv1 := arg1 asVector.	self mustBeCoordinatable: gv1.	gv1 size  =  1 ifFalse: [^self illigalCoordinate].	smVec := gv1 asSmalltalkValue.	targetIndex := smVec at: 1.	((1 to: (self currentItem vertices size)) includes: targetIndex)		ifFalse: [^self error: 'INDEX OUT OF RANGE'].	self currentItem removeVertexAt: targetIndex.	^self nullVector. 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplVertexHandler class	instanceVariableNames: ''!!GplVertexHandler class methodsFor: 'as yet unclassified' stamp: 'kf 7/15/2009 14:46'!associateArray	^{'DVERT' -> #deleteVertex:  . 'DVERTI' -> #deleteVertexIndexed:}! !!GplVertexHandler class methodsFor: 'as yet unclassified' stamp: 'kf 7/15/2009 14:45'!isFunctionAllowed: aCommandName	^false! !GplMultiHandler subclass: #GplViewingHandler	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Commands'!!GplViewingHandler methodsFor: 'handler' stamp: 'kf 5/30/2009 15:26'!fit: aToken	self mustStructureOpen.	self viewport viewFit.	 ^self nullVector. ! !!GplViewingHandler methodsFor: 'handler' stamp: 'kf 5/28/2009 17:29'!pan: aToken	| arg1 gv1 sv1 |	self mustStructureOpen.	arg1 := evaluter popArg asGplValue.	gv1 := arg1 asVector.	self mustBeCoordinatable: gv1.	gv1 size = 2 ifFalse: [^self illigalCoordinate].	sv1 := gv1 asSmalltalkValue.	self viewport viewCenter: (sv1 first @ sv1 second).	 ^self nullVector. ! !!GplViewingHandler methodsFor: 'handler' stamp: 'kf 5/28/2009 17:59'!zoom: aToken	| arg1 gv1 sv1 |	self mustStructureOpen.	arg1 := evaluter popArg asGplValue.	gv1 := arg1 asVector.	self mustBeCoordinatable: gv1.	gv1 size = 1 ifFalse: [^self error: 'RELATIVE MAGINIFY MUST SCALAR'].	sv1 := gv1 asSmalltalkValue first.	(sv1 = 0.0 or: [sv1 negative])		 ifTrue: [^self error: 'POSITIVE VALUE BUT: ', sv1 asString].	self viewport zoom: sv1.	 ^self nullVector. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplViewingHandler class	instanceVariableNames: ''!!GplViewingHandler class methodsFor: 'accessing' stamp: 'kf 5/30/2009 15:26'!associateArray	^{'PAN' -> #pan:  . 'ZOOM' -> #zoom:  . 'FIT' -> #fit: }! !!GplViewingHandler class methodsFor: 'testing' stamp: 'kf 5/29/2009 10:04'!isFunctionAllowed: aCommandName	^false! !